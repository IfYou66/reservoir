{"remainingRequest":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\src\\views\\subsystem.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\src\\views\\subsystem.vue","mtime":1640612301271},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1711181250741},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\babel-loader\\lib\\index.js","mtime":1711181252330},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1711181250741},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\vue-loader\\lib\\index.js","mtime":1711181252689}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCiAgaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnOwogIGltcG9ydCB7T3JiaXRDb250cm9sc30gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanMnOwogIGltcG9ydCB7V2F0ZXJ9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9vYmplY3RzL1dhdGVyLmpzJzsKICBpbXBvcnQge1NreX0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL29iamVjdHMvU2t5LmpzJzsKICBpbXBvcnQge1RURkxvYWRlcn0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvVFRGTG9hZGVyLmpzJzsKICBpbXBvcnQge0dMVEZMb2FkZXJ9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXIuanMnOwogIGltcG9ydCB7R1BVQ29tcHV0YXRpb25SZW5kZXJlcn0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL21pc2MvR1BVQ29tcHV0YXRpb25SZW5kZXJlci5qcyc7CgogIGV4cG9ydCBkZWZhdWx0IHsKICAgIG5hbWU6ICJmaXJzdCIsCiAgICBtZXRob2RzOiB7fSwKICAgIG1vdW50ZWQoKSB7CiAgICAgIC8qIFRFWFRVUkUgV0lEVEggRk9SIFNJTVVMQVRJT04gKi8KICAgICAgY29uc3QgV0lEVEggPSAyOwogICAgICBjb25zdCBCSVJEUyA9IDQ7CgogICAgICAvKiBCQUtFIEFOSU1BVElPTiBJTlRPIFRFWFRVUkUgYW5kIENSRUFURSBHRU9NRVRSWSBGUk9NIEJBU0UgTU9ERUwgKi8KICAgICAgY29uc3QgQmlyZEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7CiAgICAgIGxldCB0ZXh0dXJlQW5pbWF0aW9uLCBkdXJhdGlvbkFuaW1hdGlvbiwgYmlyZE1lc2gsIG1hdGVyaWFsU2hhZGVyLCB2ZXJ0ZXhQZXJCaXJkOwoKICAgICAgZnVuY3Rpb24gbmV4dFBvd2VyT2YyKG4pIHsKICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKG4pIC8gTWF0aC5sb2coMikpKTsKICAgICAgfQoKICAgICAgTWF0aC5sZXJwID0gZnVuY3Rpb24gKHZhbHVlMSwgdmFsdWUyLCBhbW91bnQpIHsKICAgICAgICBhbW91bnQgPSBNYXRoLm1heChNYXRoLm1pbihhbW91bnQsIDEpLCAwKTsKICAgICAgICByZXR1cm4gdmFsdWUxICsgKHZhbHVlMiAtIHZhbHVlMSkgKiBhbW91bnQ7CiAgICAgIH07CgogICAgICBjb25zdCBnbHRmcyA9IFsnZmlsZXMvZ2xicy9QYXJyb3QuZ2xiJywgJ2ZpbGVzL2dsYnMvRmxhbWluZ28uZ2xiJ107CiAgICAgIGNvbnN0IHNlbGVjdE1vZGVsID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZ2x0ZnMubGVuZ3RoKTsKICAgICAgbmV3IEdMVEZMb2FkZXIoKS5sb2FkKGdsdGZzW3NlbGVjdE1vZGVsXSwgZnVuY3Rpb24gKGdsdGYpIHsKICAgICAgICBjb25zdCBhbmltYXRpb25zID0gZ2x0Zi5hbmltYXRpb25zOwogICAgICAgIGR1cmF0aW9uQW5pbWF0aW9uID0gTWF0aC5yb3VuZChhbmltYXRpb25zWzBdLmR1cmF0aW9uICogNjApOwogICAgICAgIGNvbnN0IGJpcmRHZW8gPSBnbHRmLnNjZW5lLmNoaWxkcmVuWzBdLmdlb21ldHJ5OwogICAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGJpcmRHZW8ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uOwogICAgICAgIGNvbnN0IHRIZWlnaHQgPSBuZXh0UG93ZXJPZjIoZHVyYXRpb25BbmltYXRpb24pOwogICAgICAgIGNvbnN0IHRXaWR0aCA9IG5leHRQb3dlck9mMihiaXJkR2VvLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5jb3VudCk7CiAgICAgICAgdmVydGV4UGVyQmlyZCA9IGJpcmRHZW8uZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLmNvdW50OwogICAgICAgIGNvbnN0IHREYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzICogdFdpZHRoICogdEhlaWdodCk7CgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdFdpZHRoOyBpKyspIHsKICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdEhlaWdodDsgaisrKSB7CiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGogKiB0V2lkdGggKiAzOwogICAgICAgICAgICBjb25zdCBjdXJNb3JwaCA9IE1hdGguZmxvb3IoaiAvIGR1cmF0aW9uQW5pbWF0aW9uICogbW9ycGhBdHRyaWJ1dGVzLmxlbmd0aCk7CiAgICAgICAgICAgIGNvbnN0IG5leHRNb3JwaCA9IChNYXRoLmZsb29yKGogLyBkdXJhdGlvbkFuaW1hdGlvbiAqIG1vcnBoQXR0cmlidXRlcy5sZW5ndGgpICsgMSkgJSBtb3JwaEF0dHJpYnV0ZXMubGVuZ3RoOwogICAgICAgICAgICBjb25zdCBsZXJwQW1vdW50ID0gaiAvIGR1cmF0aW9uQW5pbWF0aW9uICogbW9ycGhBdHRyaWJ1dGVzLmxlbmd0aCAlIDE7CgogICAgICAgICAgICBpZiAoaiA8IGR1cmF0aW9uQW5pbWF0aW9uKSB7CiAgICAgICAgICAgICAgbGV0IGQwLCBkMTsKICAgICAgICAgICAgICBkMCA9IG1vcnBoQXR0cmlidXRlc1tjdXJNb3JwaF0uYXJyYXlbaSAqIDNdOwogICAgICAgICAgICAgIGQxID0gbW9ycGhBdHRyaWJ1dGVzW25leHRNb3JwaF0uYXJyYXlbaSAqIDNdOwogICAgICAgICAgICAgIGlmIChkMCAhPT0gdW5kZWZpbmVkICYmIGQxICE9PSB1bmRlZmluZWQpIHREYXRhW29mZnNldCArIGkgKiAzXSA9IE1hdGgubGVycChkMCwgZDEsIGxlcnBBbW91bnQpOwogICAgICAgICAgICAgIGQwID0gbW9ycGhBdHRyaWJ1dGVzW2N1ck1vcnBoXS5hcnJheVtpICogMyArIDFdOwogICAgICAgICAgICAgIGQxID0gbW9ycGhBdHRyaWJ1dGVzW25leHRNb3JwaF0uYXJyYXlbaSAqIDMgKyAxXTsKICAgICAgICAgICAgICBpZiAoZDAgIT09IHVuZGVmaW5lZCAmJiBkMSAhPT0gdW5kZWZpbmVkKSB0RGF0YVtvZmZzZXQgKyBpICogMyArIDFdID0gTWF0aC5sZXJwKGQwLCBkMSwgbGVycEFtb3VudCk7CiAgICAgICAgICAgICAgZDAgPSBtb3JwaEF0dHJpYnV0ZXNbY3VyTW9ycGhdLmFycmF5W2kgKiAzICsgMl07CiAgICAgICAgICAgICAgZDEgPSBtb3JwaEF0dHJpYnV0ZXNbbmV4dE1vcnBoXS5hcnJheVtpICogMyArIDJdOwogICAgICAgICAgICAgIGlmIChkMCAhPT0gdW5kZWZpbmVkICYmIGQxICE9PSB1bmRlZmluZWQpIHREYXRhW29mZnNldCArIGkgKiAzICsgMl0gPSBNYXRoLmxlcnAoZDAsIGQxLCBsZXJwQW1vdW50KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgdGV4dHVyZUFuaW1hdGlvbiA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSh0RGF0YSwgdFdpZHRoLCB0SGVpZ2h0LCBUSFJFRS5SR0JGb3JtYXQsIFRIUkVFLkZsb2F0VHlwZSk7CiAgICAgICAgdGV4dHVyZUFuaW1hdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7CgogICAgICAgIGNvbnN0IHZlcnRpY2VzID0gW10sIGNvbG9yID0gW10sIHJlZmVyZW5jZSA9IFtdLCBzZWVkcyA9IFtdLCBpbmRpY2VzID0gW107CiAgICAgICAgY29uc3QgdG90YWxWZXJ0aWNlcyA9IGJpcmRHZW8uZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLmNvdW50ICogMyAqIEJJUkRTOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxWZXJ0aWNlczsgaSsrKSB7CiAgICAgICAgICBjb25zdCBiSW5kZXggPSBpICUgKGJpcmRHZW8uZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLmNvdW50ICogMyk7CiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKGJpcmRHZW8uZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLmFycmF5W2JJbmRleF0pOwogICAgICAgICAgY29sb3IucHVzaChiaXJkR2VvLmdldEF0dHJpYnV0ZSgnY29sb3InKS5hcnJheVtiSW5kZXhdKTsKICAgICAgICB9CgogICAgICAgIGxldCByID0gTWF0aC5yYW5kb20oKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpcmRHZW8uZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLmNvdW50ICogQklSRFM7IGkrKykgewogICAgICAgICAgY29uc3QgYkluZGV4ID0gaSAlIChiaXJkR2VvLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5jb3VudCk7CiAgICAgICAgICBjb25zdCBiaXJkID0gTWF0aC5mbG9vcihpIC8gYmlyZEdlby5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykuY291bnQpOwogICAgICAgICAgaWYgKGJJbmRleCA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCk7CiAgICAgICAgICBjb25zdCBqID0gfn5iaXJkOwogICAgICAgICAgY29uc3QgeCA9IChqICUgV0lEVEgpIC8gV0lEVEg7CiAgICAgICAgICBjb25zdCB5ID0gfn4oaiAvIFdJRFRIKSAvIFdJRFRIOwogICAgICAgICAgcmVmZXJlbmNlLnB1c2goeCwgeSwgYkluZGV4IC8gdFdpZHRoLCBkdXJhdGlvbkFuaW1hdGlvbiAvIHRIZWlnaHQpOwogICAgICAgICAgc2VlZHMucHVzaChiaXJkLCByLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTsKICAgICAgICB9CgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmlyZEdlby5pbmRleC5hcnJheS5sZW5ndGggKiBCSVJEUzsgaSsrKSB7CiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKGkgLyBiaXJkR2VvLmluZGV4LmFycmF5Lmxlbmd0aCkgKiAoYmlyZEdlby5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykuY291bnQpOwogICAgICAgICAgaW5kaWNlcy5wdXNoKGJpcmRHZW8uaW5kZXguYXJyYXlbaSAlIGJpcmRHZW8uaW5kZXguYXJyYXkubGVuZ3RoXSArIG9mZnNldCk7CiAgICAgICAgfQoKICAgICAgICBCaXJkR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyksIDMpKTsKICAgICAgICBCaXJkR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdiaXJkQ29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoY29sb3IpLCAzKSk7CiAgICAgICAgQmlyZEdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoY29sb3IpLCAzKSk7CiAgICAgICAgQmlyZEdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncmVmZXJlbmNlJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KHJlZmVyZW5jZSksIDQpKTsKICAgICAgICBCaXJkR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdzZWVkcycsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShzZWVkcyksIDQpKTsKCiAgICAgICAgQmlyZEdlb21ldHJ5LnNldEluZGV4KGluZGljZXMpOwoKICAgICAgICBpbml0KCk7CiAgICAgICAgYW5pbWF0ZSgpOwoKICAgICAgfSk7CgoKICAgICAgbGV0IGNvbnRhaW5lciwgc3RhdHM7CiAgICAgIGxldCBjYW1lcmEsIHNjZW5lLCByZW5kZXJlcjsKICAgICAgbGV0IG1vdXNlWCA9IDAsIG1vdXNlWSA9IDA7CgogICAgICBsZXQgd2luZG93SGFsZlggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDI7CiAgICAgIGxldCB3aW5kb3dIYWxmWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7CgogICAgICBjb25zdCBCT1VORFMgPSA4MDAsIEJPVU5EU19IQUxGID0gQk9VTkRTIC8gMjsKCiAgICAgIGxldCBsYXN0ID0gcGVyZm9ybWFuY2Uubm93KCk7CgogICAgICBsZXQgZ3B1Q29tcHV0ZTsKICAgICAgbGV0IHZlbG9jaXR5VmFyaWFibGU7CiAgICAgIGxldCBwb3NpdGlvblZhcmlhYmxlOwogICAgICBsZXQgcG9zaXRpb25Vbmlmb3JtczsKICAgICAgbGV0IHZlbG9jaXR5VW5pZm9ybXM7CgogICAgICBsZXQgY29udHJvbHMsIHdhdGVyLCBzdW47CiAgICAgIGxldCBtZXNoZXM7CiAgICAgIGxldCBpbmlNZXNoZXMgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgbWVzaGVzID0gWwogICAgICAgICAgewogICAgICAgICAgICBuYW1lOiAnbWVzaDAnLAogICAgICAgICAgICBwb3M6IHt4OiAtNjAsIHk6IDAsIHo6IDYwfSwKICAgICAgICAgICAgdXJsOiAnIycsCiAgICAgICAgICAgIGltZzogcmVxdWlyZSgnQC9hc3NldHMvZmxhc2gvbW9uaXRvci5wbmcnKSwKICAgICAgICAgICAgcm90OiB7eDogMC4xLCB5OiAwLjIsIHo6IDAuNX0KICAgICAgICAgIH0sCgogICAgICAgICAgewogICAgICAgICAgICBuYW1lOiAnbWVzaDInLAogICAgICAgICAgICBwb3M6IHt4OiAtMCwgeTogMCwgejogNDB9LAogICAgICAgICAgICB1cmw6ICcvcmVzZXJ2b2lyJywKICAgICAgICAgICAgaW1nOiByZXF1aXJlKCdAL2Fzc2V0cy9mbGFzaC9tYW5hZ2UucG5nJyksCiAgICAgICAgICAgIHJvdDoge3g6IDAuMywgeTogMC4yLCB6OiAwLjN9CiAgICAgICAgICB9LAoKICAgICAgICAgIHsKICAgICAgICAgICAgbmFtZTogJ21lc2g0JywKICAgICAgICAgICAgcG9zOiB7eDogNjAsIHk6IDAsIHo6IDQwfSwKICAgICAgICAgICAgdXJsOiAnIycsCiAgICAgICAgICAgIGltZzogcmVxdWlyZSgnQC9hc3NldHMvZmxhc2gvYXBwcmlzZS5wbmcnKSwKICAgICAgICAgICAgcm90OiB7eDogMC41LCB5OiAwLjIsIHo6IDAuMX0KICAgICAgICAgIH0sCiAgICAgICAgXTsKICAgICAgfSgpOwoKCiAgICAgIGxldCBncm91cCwgdGV4dE1lc2gxLCB0ZXh0TWVzaDIsIHRleHRHZW8sIG1hdGVyaWFsOwoKICAgICAgbGV0IHRleHQgPSAn5ruV5bee5biC5pWw5a2X5rC05bqT55uR566h5bmz5Y+wJzsKICAgICAgY29uc3QgaGVpZ2h0ID0gMjAsCiAgICAgICAgc2l6ZSA9IDcwLAogICAgICAgIGhvdmVyID0gMzAsCiAgICAgICAgY3VydmVTZWdtZW50cyA9IDQsCiAgICAgICAgYmV2ZWxUaGlja25lc3MgPSAyLAogICAgICAgIGJldmVsU2l6ZSA9IDEuNTsKCiAgICAgIGxldCBmb250ID0gbnVsbDsKICAgICAgY29uc3QgbWlycm9yID0gdHJ1ZTsKCgogICAgICBsZXQgaW5BcmVhID0gZmFsc2U7CiAgICAgIGxldCBjdXJyZW50SW5kZXggPSBudWxsOwoKCiAgICAgIGFkZFRvdWNoKCk7CgogICAgICBmdW5jdGlvbiBhZGRUb3VjaCgpIHsKICAgICAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkgewogICAgICAgICAgbGV0IGludGVyc2VjdCA9IGdldEludGVyc2VjdCgpOwogICAgICAgICAgaWYgKGludGVyc2VjdCkgewogICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICJwb2ludGVyIjsKICAgICAgICAgICAgbGV0IG1lc2ggPSBtZXNoZXNbaW50ZXJzZWN0Lm9iamVjdC5pbmRleF07CiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGludGVyc2VjdC5vYmplY3QuaW5kZXg7CiAgICAgICAgICAgIG1lc2gucm90LnggPSAwOwogICAgICAgICAgICBtZXNoLnJvdC56ID0gMDsKICAgICAgICAgICAgbWVzaC5yb3QueSA9IDA7CiAgICAgICAgICAgIG1lc2gucG9zLnkgPSA1OwogICAgICAgICAgICBpbkFyZWEgPSB0cnVlOwogICAgICAgICAgICByZW5kZXIoKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmIChpbkFyZWEpIHsKICAgICAgICAgICAgICBpbkFyZWEgPSBmYWxzZTsKICAgICAgICAgICAgICBtZXNoZXNbY3VycmVudEluZGV4XS5yb3QueCA9IChjdXJyZW50SW5kZXggKyAxKSAqIDAuMTsKICAgICAgICAgICAgICBtZXNoZXNbY3VycmVudEluZGV4XS5yb3QueSA9IDAuMjsKICAgICAgICAgICAgICBtZXNoZXNbY3VycmVudEluZGV4XS5yb3QueiA9IChtZXNoZXMubGVuZ3RoIC0gY3VycmVudEluZGV4IC0gMSkgKiAwLjE7CiAgICAgICAgICAgICAgbWVzaGVzW2N1cnJlbnRJbmRleF0ucG9zLnkgPSAwOwogICAgICAgICAgICAgIHJlbmRlcigpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gImRlZmF1bHQiOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZUNsaWNrKGV2ZW50KSB7CiAgICAgICAgICBsZXQgaW50ZXJzZWN0ID0gZ2V0SW50ZXJzZWN0KCk7CiAgICAgICAgICBpZiAoaW50ZXJzZWN0KSB7CiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZmluZE1lc2goaW50ZXJzZWN0Lm9iamVjdC5wb3NpdGlvbi54KS51cmw7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBmaW5kTWVzaCh4KSB7CiAgICAgICAgICBmb3IgKGxldCBtZXNoIG9mIG1lc2hlcykgewogICAgICAgICAgICBpZiAoeCA9PT0gbWVzaC5wb3MueCkgewogICAgICAgICAgICAgIHJldHVybiBtZXNoOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3QoKSB7CiAgICAgICAgICAvL+WjsOaYjuWwhOe6v+WSjG1vdXNl5Y+Y6YePCiAgICAgICAgICBsZXQgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpOwogICAgICAgICAgbGV0IG1vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoKTsKCiAgICAgICAgICAvL+mAmui/h+m8oOagh+eCueWHu+eahOS9jee9ruiuoeeul+WHuuWwhOe6v+aJgOmcgOimgeeahOeCueeahOS9jee9ru+8jOS7peWxj+W5leS4reW/g+S4uuWOn+eCue+8jOWAvOeahOiMg+WbtOS4ui0x5YiwMS4KICAgICAgICAgIG1vdXNlLnggPSAoZXZlbnQuY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxOwogICAgICAgICAgbW91c2UueSA9IC0oZXZlbnQuY2xpZW50WSAvIHdpbmRvdy5pbm5lckhlaWdodCkgKiAyICsgMTsKCiAgICAgICAgICAvL+agueaNruWcqOWxj+W5leeahOS6jOe7tOS9jee9ruS7peWPiuebuOacuueahOefqemYteabtOaWsOWwhOe6v+eahOS9jee9rgogICAgICAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobW91c2UsIGNhbWVyYSk7CgogICAgICAgICAgLy8g6I635Y+W5bCE57q/55u057q/5ZKM5omA5pyJ5qih5Z6L55u45Lqk55qE5pWw57uE6ZuG5ZCICiAgICAgICAgICBsZXQgaW50ZXJzZWN0cyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKHNjZW5lLmNoaWxkcmVuLCB0cnVlKTsgLy/lop7liqDnrKzkuozkuKrlj4LmlbDvvIzlj6/ku6XpgY3ljoblrZDlrZDlrZnlrZnlr7nosaEKICAgICAgICAgIC8v5Yik5pat5b2T5YmN5pWw57uE5piv5ZCm5Li656m6LOS4jeS4uuepuuWImeiOt+WPluacgOi/keeahOeahOaooeWei++8jOWwhuWFtuminOiJsuS/ruaUueS4uue6ouiJsgogICAgICAgICAgaWYgKGludGVyc2VjdHMubGVuZ3RoID4gMikgewogICAgICAgICAgICBmb3IgKGxldCBpbnRlcnNlY3Qgb2YgaW50ZXJzZWN0cykgewogICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Qub2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCAmJiAoaW50ZXJzZWN0Lm9iamVjdC5pbmRleCA+PSAwKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIiwgb25Nb3VzZUNsaWNrLCBmYWxzZSk7CiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigibW91c2Vtb3ZlIiwgb25Nb3VzZU1vdmUsIGZhbHNlKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gaW5pdCgpIHsKICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJyk7CgogICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTsKICAgICAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTsKICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpOwogICAgICAgIHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nOwogICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTsKICAgICAgICAvLwoKICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOwoKICAgICAgICBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzAsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAxLCAyMDAwMCk7CiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnNldCgzMCwgMzAsIDEwMCk7CiAgICAgICAgLy8KCiAgICAgICAgc3VuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTsKCiAgICAgICAgLy8gV2F0ZXIKICAgICAgICBjb25zdCB3YXRlckdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoMTAwMDAsIDEwMDAwKTsKICAgICAgICB3YXRlciA9IG5ldyBXYXRlcigKICAgICAgICAgIHdhdGVyR2VvbWV0cnksCiAgICAgICAgICB7CiAgICAgICAgICAgIHRleHR1cmVXaWR0aDogNTEyLAogICAgICAgICAgICB0ZXh0dXJlSGVpZ2h0OiA1MTIsCiAgICAgICAgICAgIHdhdGVyTm9ybWFsczogbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKHJlcXVpcmUoJ0AvYXNzZXRzL2ZsYXNoL3dhdGVybm9ybWFscy5qcGcnKSwgZnVuY3Rpb24gKHRleHR1cmUpIHsKICAgICAgICAgICAgICB0ZXh0dXJlLndyYXBTID0gdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nOwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgc3VuRGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLAogICAgICAgICAgICBzdW5Db2xvcjogMHhmZmZmZmYsCiAgICAgICAgICAgIHdhdGVyQ29sb3I6IDB4MDAxZTBmLAogICAgICAgICAgICBkaXN0b3J0aW9uU2NhbGU6IDEwLAogICAgICAgICAgICBmb2c6IHNjZW5lLmZvZyAhPT0gdW5kZWZpbmVkCiAgICAgICAgICB9CiAgICAgICAgKTsKICAgICAgICB3YXRlci5yb3RhdGlvbi54ID0gLU1hdGguUEkgLyAyOwogICAgICAgIHNjZW5lLmFkZCh3YXRlcik7CgogICAgICAgIC8vIFNreWJveAogICAgICAgIGNvbnN0IHNreSA9IG5ldyBTa3koKTsKICAgICAgICBza3kuc2NhbGUuc2V0U2NhbGFyKDEwMDAwKTsKICAgICAgICBzY2VuZS5hZGQoc2t5KTsKCiAgICAgICAgY29uc3Qgc2t5VW5pZm9ybXMgPSBza3kubWF0ZXJpYWwudW5pZm9ybXM7CiAgICAgICAgc2t5VW5pZm9ybXNbJ3R1cmJpZGl0eSddLnZhbHVlID0gMTA7CiAgICAgICAgc2t5VW5pZm9ybXNbJ3JheWxlaWdoJ10udmFsdWUgPSA5OwogICAgICAgIHNreVVuaWZvcm1zWydtaWVDb2VmZmljaWVudCddLnZhbHVlID0gMC4wMDU7CiAgICAgICAgc2t5VW5pZm9ybXNbJ21pZURpcmVjdGlvbmFsRyddLnZhbHVlID0gMC44OwoKICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gewogICAgICAgICAgZWxldmF0aW9uOiAoKDEyIC0gTWF0aC5hYnMobmV3IERhdGUoKS5nZXRIb3VycygpICsgbmV3IERhdGUoKS5nZXRNaW51dGVzKCkgLyA2MCAtIDEyKSkgKiA0MCAvIDEyIC0gMjApICogMiwKICAgICAgICAgIGF6aW11dGg6ICgxMiAtIG5ldyBEYXRlKCkuZ2V0SG91cnMoKSAtIG5ldyBEYXRlKCkuZ2V0TWludXRlcygpIC8gNjApICogMTAgLSAxNzAKICAgICAgICB9OwoKICAgICAgICBjb25zdCBwbXJlbUdlbmVyYXRvciA9IG5ldyBUSFJFRS5QTVJFTUdlbmVyYXRvcihyZW5kZXJlcik7CgogICAgICAgIGxldCB1cGRhdGVTdW4gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBjb25zdCBwaGkgPSBUSFJFRS5NYXRoVXRpbHMuZGVnVG9SYWQoOTAgLSBwYXJhbWV0ZXJzLmVsZXZhdGlvbik7CiAgICAgICAgICBjb25zdCB0aGV0YSA9IFRIUkVFLk1hdGhVdGlscy5kZWdUb1JhZChwYXJhbWV0ZXJzLmF6aW11dGgpOwoKICAgICAgICAgIHN1bi5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKDEsIHBoaSwgdGhldGEpOwogICAgICAgICAgc2t5Lm1hdGVyaWFsLnVuaWZvcm1zWydzdW5Qb3NpdGlvbiddLnZhbHVlLmNvcHkoc3VuKTsKICAgICAgICAgIHdhdGVyLm1hdGVyaWFsLnVuaWZvcm1zWydzdW5EaXJlY3Rpb24nXS52YWx1ZS5jb3B5KHN1bikubm9ybWFsaXplKCk7CiAgICAgICAgICBzY2VuZS5lbnZpcm9ubWVudCA9IHBtcmVtR2VuZXJhdG9yLmZyb21TY2VuZShza3kpLnRleHR1cmU7CiAgICAgICAgfSgpOwoKICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgyMCwgMjAsIDIwKTsKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNoZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQobWVzaGVzW2ldLmltZyk7CiAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7bWFwOiB0ZXh0dXJlfSk7CgogICAgICAgICAgbGV0IG0gPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpOwogICAgICAgICAgbS5pbmRleCA9IGk7CiAgICAgICAgICBzY2VuZS5hZGQobSk7CiAgICAgICAgICBtZXNoZXNbaV0ub2JqID0gbTsKICAgICAgICB9CgogICAgICAgIGNvbnN0IGdlbyA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgzMCwgMzAsIDMwKTsKICAgICAgICBjb25zdCB0ZXggPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQocmVxdWlyZSgnQC9hc3NldHMvbG9nby93YXRlci5wbmcnKSk7CiAgICAgICAgY29uc3QgbWF0ID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHttYXA6IHRleH0pOwogICAgICAgIGxldCBpY29uTWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KTsKICAgICAgICBpY29uTWVzaC5wb3NpdGlvbi54ID0gLTgwMDsKICAgICAgICBpY29uTWVzaC5wb3NpdGlvbi55ID0gODg7CiAgICAgICAgaWNvbk1lc2gucG9zaXRpb24ueiA9IC01MDA7CiAgICAgICAgaWNvbk1lc2gucm90YXRpb24ueSA9IDcuMjQ7CiAgICAgICAgaWNvbk1lc2gucm90YXRpb24ueCA9IDkuNTsKICAgICAgICBpY29uTWVzaC5yb3RhdGlvbi56ID0gOS40OwogICAgICAgIHNjZW5lLmFkZChpY29uTWVzaCk7ICAgLy/niYjmnYPpl67popjvvIzmmoLml7bkuI3lvIDlkK8KCiAgICAgICAgY29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyhjYW1lcmEsIHJlbmRlcmVyLmRvbUVsZW1lbnQpOwogICAgICAgIGNvbnRyb2xzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJICogMC40OTU7CiAgICAgICAgY29udHJvbHMudGFyZ2V0LnNldCgwLCAxMCwgMCk7CiAgICAgICAgY29udHJvbHMubWluRGlzdGFuY2UgPSA1MC4wOwogICAgICAgIGNvbnRyb2xzLm1heERpc3RhbmNlID0gNDgwMC4wOwogICAgICAgIGNvbnRyb2xzLnVwZGF0ZSgpOwoKICAgICAgICAvLwogICAgICAgIGNvbnN0IGRpckxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDAuMTI1KTsKICAgICAgICBkaXJMaWdodC5wb3NpdGlvbi5zZXQoMCwgMCwgMSkubm9ybWFsaXplKCk7CiAgICAgICAgc2NlbmUuYWRkKGRpckxpZ2h0KTsKCiAgICAgICAgY29uc3QgcG9pbnRMaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KDB4ZmZmZmZmLCAxLjUpOwogICAgICAgIHBvaW50TGlnaHQucG9zaXRpb24uc2V0KDAsIDIwMCwgOTApOwogICAgICAgIHBvaW50TGlnaHQuY29sb3Iuc2V0SFNMKDAuMSwgMSwgMC4zKTsKICAgICAgICBzY2VuZS5hZGQocG9pbnRMaWdodCk7CgogICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtjb2xvcjogMHhmZmZmZmYsIGZsYXRTaGFkaW5nOiB0cnVlfSk7CiAgICAgICAgLy8KICAgICAgICBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpOwogICAgICAgIGdyb3VwLnBvc2l0aW9uLnkgPSAxMDA7CgogICAgICAgIHNjZW5lLmFkZChncm91cCk7CgogICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBUVEZMb2FkZXIoKTsKCiAgICAgICAgbG9hZGVyLmxvYWQocmVxdWlyZSgnQC9hc3NldHMvZmxhc2gvdGl0bGUudHRmJyksIGZ1bmN0aW9uIChqc29uKSB7CiAgICAgICAgICBmb250ID0gbmV3IFRIUkVFLkZvbnQoanNvbik7CiAgICAgICAgICBjcmVhdGVUZXh0KCk7CiAgICAgICAgfSk7CgoKICAgICAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTsKCiAgICAgICAgaW5pdENvbXB1dGVSZW5kZXJlcigpOwogICAgICAgIGluaXRCaXJkcygpOwogICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJzsKICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvblBvaW50ZXJNb3ZlKTsKCiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gaW5pdENvbXB1dGVSZW5kZXJlcigpIHsKICAgICAgICBncHVDb21wdXRlID0gbmV3IEdQVUNvbXB1dGF0aW9uUmVuZGVyZXIoV0lEVEgsIFdJRFRILCByZW5kZXJlcik7CgogICAgICAgIGNvbnN0IGR0UG9zaXRpb24gPSBncHVDb21wdXRlLmNyZWF0ZVRleHR1cmUoKTsKICAgICAgICBjb25zdCBkdFZlbG9jaXR5ID0gZ3B1Q29tcHV0ZS5jcmVhdGVUZXh0dXJlKCk7CiAgICAgICAgZmlsbFBvc2l0aW9uVGV4dHVyZShkdFBvc2l0aW9uKTsKICAgICAgICBmaWxsVmVsb2NpdHlUZXh0dXJlKGR0VmVsb2NpdHkpOwoKICAgICAgICB2ZWxvY2l0eVZhcmlhYmxlID0gZ3B1Q29tcHV0ZS5hZGRWYXJpYWJsZSgidGV4dHVyZVZlbG9jaXR5IiwKICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHRpbWU7XG4nICsKICAgICAgICAgICdcdFx0XHR1bmlmb3JtIGZsb2F0IHRlc3Rpbmc7XG4nICsKICAgICAgICAgICdcdFx0XHR1bmlmb3JtIGZsb2F0IGRlbHRhOyAvLyBhYm91dCAwLjAxNlxuJyArCiAgICAgICAgICAnXHRcdFx0dW5pZm9ybSBmbG9hdCBzZXBhcmF0aW9uRGlzdGFuY2U7IC8vIDIwXG4nICsKICAgICAgICAgICdcdFx0XHR1bmlmb3JtIGZsb2F0IGFsaWdubWVudERpc3RhbmNlOyAvLyA0MFxuJyArCiAgICAgICAgICAnXHRcdFx0dW5pZm9ybSBmbG9hdCBjb2hlc2lvbkRpc3RhbmNlOyAvL1xuJyArCiAgICAgICAgICAnXHRcdFx0dW5pZm9ybSBmbG9hdCBmcmVlZG9tRmFjdG9yO1xuJyArCiAgICAgICAgICAnXHRcdFx0dW5pZm9ybSB2ZWMzIHByZWRhdG9yO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRjb25zdCBmbG9hdCB3aWR0aCA9IHJlc29sdXRpb24ueDtcbicgKwogICAgICAgICAgJ1x0XHRcdGNvbnN0IGZsb2F0IGhlaWdodCA9IHJlc29sdXRpb24ueTtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0Y29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU4OTc5MztcbicgKwogICAgICAgICAgJ1x0XHRcdGNvbnN0IGZsb2F0IFBJXzIgPSBQSSAqIDIuMDtcbicgKwogICAgICAgICAgJ1x0XHRcdC8vIGNvbnN0IGZsb2F0IFZJU0lPTiA9IFBJICogMC41NTtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0ZmxvYXQgem9uZVJhZGl1cyA9IDQwLjA7XG4nICsKICAgICAgICAgICdcdFx0XHRmbG9hdCB6b25lUmFkaXVzU3F1YXJlZCA9IDE2MDAuMDtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0ZmxvYXQgc2VwYXJhdGlvblRocmVzaCA9IDAuNDU7XG4nICsKICAgICAgICAgICdcdFx0XHRmbG9hdCBhbGlnbm1lbnRUaHJlc2ggPSAwLjY1O1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRjb25zdCBmbG9hdCBVUFBFUl9CT1VORFMgPSBCT1VORFM7XG4nICsKICAgICAgICAgICdcdFx0XHRjb25zdCBmbG9hdCBMT1dFUl9CT1VORFMgPSAtVVBQRVJfQk9VTkRTO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRjb25zdCBmbG9hdCBTUEVFRF9MSU1JVCA9IDkuMDtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0ZmxvYXQgcmFuZCggdmVjMiBjbyApe1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRyZXR1cm4gZnJhY3QoIHNpbiggZG90KCBjby54eSwgdmVjMigxMi45ODk4LDc4LjIzMykgKSApICogNDM3NTguNTQ1MyApO1xuJyArCiAgICAgICAgICAnXHRcdFx0fVxuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHR2b2lkIG1haW4oKSB7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0em9uZVJhZGl1cyA9IHNlcGFyYXRpb25EaXN0YW5jZSArIGFsaWdubWVudERpc3RhbmNlICsgY29oZXNpb25EaXN0YW5jZTtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0c2VwYXJhdGlvblRocmVzaCA9IHNlcGFyYXRpb25EaXN0YW5jZSAvIHpvbmVSYWRpdXM7XG4nICsKICAgICAgICAgICdcdFx0XHRcdGFsaWdubWVudFRocmVzaCA9ICggc2VwYXJhdGlvbkRpc3RhbmNlICsgYWxpZ25tZW50RGlzdGFuY2UgKSAvIHpvbmVSYWRpdXM7XG4nICsKICAgICAgICAgICdcdFx0XHRcdHpvbmVSYWRpdXNTcXVhcmVkID0gem9uZVJhZGl1cyAqIHpvbmVSYWRpdXM7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHR2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbi54eTtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0dmVjMyBiaXJkUG9zaXRpb24sIGJpcmRWZWxvY2l0eTtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHR2ZWMzIHNlbGZQb3NpdGlvbiA9IHRleHR1cmUyRCggdGV4dHVyZVBvc2l0aW9uLCB1diApLnh5ejtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0dmVjMyBzZWxmVmVsb2NpdHkgPSB0ZXh0dXJlMkQoIHRleHR1cmVWZWxvY2l0eSwgdXYgKS54eXo7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZmxvYXQgZGlzdDtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0dmVjMyBkaXI7IC8vIGRpcmVjdGlvblxuJyArCiAgICAgICAgICAnXHRcdFx0XHRmbG9hdCBkaXN0U3F1YXJlZDtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRmbG9hdCBzZXBhcmF0aW9uU3F1YXJlZCA9IHNlcGFyYXRpb25EaXN0YW5jZSAqIHNlcGFyYXRpb25EaXN0YW5jZTtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZmxvYXQgY29oZXNpb25TcXVhcmVkID0gY29oZXNpb25EaXN0YW5jZSAqIGNvaGVzaW9uRGlzdGFuY2U7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZmxvYXQgZjtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZmxvYXQgcGVyY2VudDtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHR2ZWMzIHZlbG9jaXR5ID0gc2VsZlZlbG9jaXR5O1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdGZsb2F0IGxpbWl0ID0gU1BFRURfTElNSVQ7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZGlyID0gcHJlZGF0b3IgKiBVUFBFUl9CT1VORFMgLSBzZWxmUG9zaXRpb247XG4nICsKICAgICAgICAgICdcdFx0XHRcdGRpci56ID0gMC47XG4nICsKICAgICAgICAgICdcdFx0XHRcdC8vIGRpci56ICo9IDAuNjtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZGlzdCA9IGxlbmd0aCggZGlyICk7XG4nICsKICAgICAgICAgICdcdFx0XHRcdGRpc3RTcXVhcmVkID0gZGlzdCAqIGRpc3Q7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZmxvYXQgcHJleVJhZGl1cyA9IDE1MC4wO1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRmbG9hdCBwcmV5UmFkaXVzU3EgPSBwcmV5UmFkaXVzICogcHJleVJhZGl1cztcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdC8vIG1vdmUgYmlyZHMgYXdheSBmcm9tIHByZWRhdG9yXG4nICsKICAgICAgICAgICdcdFx0XHRcdGlmICggZGlzdCA8IHByZXlSYWRpdXMgKSB7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRmID0gKCBkaXN0U3F1YXJlZCAvIHByZXlSYWRpdXNTcSAtIDEuMCApICogZGVsdGEgKiAxMDAuO1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdHZlbG9jaXR5ICs9IG5vcm1hbGl6ZSggZGlyICkgKiBmO1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdGxpbWl0ICs9IDUuMDtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0fVxuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0Ly8gaWYgKHRlc3RpbmcgPT0gMC4wKSB7fVxuJyArCiAgICAgICAgICAnXHRcdFx0XHQvLyBpZiAoIHJhbmQoIHV2ICsgdGltZSApIDwgZnJlZWRvbUZhY3RvciApIHt9XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHQvLyBBdHRyYWN0IGZsb2NrcyB0byB0aGUgY2VudGVyXG4nICsKICAgICAgICAgICdcdFx0XHRcdHZlYzMgY2VudHJhbCA9IHZlYzMoIDAuLCAwLiwgMC4gKTtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZGlyID0gc2VsZlBvc2l0aW9uIC0gY2VudHJhbDtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZGlzdCA9IGxlbmd0aCggZGlyICk7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0ZGlyLnkgKj0gMi41O1xuJyArCiAgICAgICAgICAnXHRcdFx0XHR2ZWxvY2l0eSAtPSBub3JtYWxpemUoIGRpciApICogZGVsdGEgKiA1LjtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRmb3IgKCBmbG9hdCB5ID0gMC4wOyB5IDwgaGVpZ2h0OyB5KysgKSB7XG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0Zm9yICggZmxvYXQgeCA9IDAuMDsgeCA8IHdpZHRoOyB4KysgKSB7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdHZlYzIgcmVmID0gdmVjMiggeCArIDAuNSwgeSArIDAuNSApIC8gcmVzb2x1dGlvbi54eTtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdGJpcmRQb3NpdGlvbiA9IHRleHR1cmUyRCggdGV4dHVyZVBvc2l0aW9uLCByZWYgKS54eXo7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdGRpciA9IGJpcmRQb3NpdGlvbiAtIHNlbGZQb3NpdGlvbjtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdGRpc3QgPSBsZW5ndGgoIGRpciApO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCAwLjAwMDEgKSBjb250aW51ZTtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0ZGlzdFNxdWFyZWQgPSBkaXN0ICogZGlzdDtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3F1YXJlZCA+IHpvbmVSYWRpdXNTcXVhcmVkICkgY29udGludWU7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdHBlcmNlbnQgPSBkaXN0U3F1YXJlZCAvIHpvbmVSYWRpdXNTcXVhcmVkO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHRpZiAoIHBlcmNlbnQgPCBzZXBhcmF0aW9uVGhyZXNoICkgeyAvLyBsb3dcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0XHQvLyBTZXBhcmF0aW9uIC0gTW92ZSBhcGFydCBmb3IgY29tZm9ydFxuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0XHRmID0gKCBzZXBhcmF0aW9uVGhyZXNoIC8gcGVyY2VudCAtIDEuMCApICogZGVsdGE7XG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHRcdHZlbG9jaXR5IC09IG5vcm1hbGl6ZSggZGlyICkgKiBmO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwZXJjZW50IDwgYWxpZ25tZW50VGhyZXNoICkgeyAvLyBoaWdoXG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdFx0Ly8gQWxpZ25tZW50IC0gZmx5IHRoZSBzYW1lIGRpcmVjdGlvblxuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0XHRmbG9hdCB0aHJlc2hEZWx0YSA9IGFsaWdubWVudFRocmVzaCAtIHNlcGFyYXRpb25UaHJlc2g7XG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHRcdGZsb2F0IGFkanVzdGVkUGVyY2VudCA9ICggcGVyY2VudCAtIHNlcGFyYXRpb25UaHJlc2ggKSAvIHRocmVzaERlbHRhO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHRcdGJpcmRWZWxvY2l0eSA9IHRleHR1cmUyRCggdGV4dHVyZVZlbG9jaXR5LCByZWYgKS54eXo7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdFx0ZiA9ICggMC41IC0gY29zKCBhZGp1c3RlZFBlcmNlbnQgKiBQSV8yICkgKiAwLjUgKyAwLjUgKSAqIGRlbHRhO1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0XHR2ZWxvY2l0eSArPSBub3JtYWxpemUoIGJpcmRWZWxvY2l0eSApICogZjtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0fSBlbHNlIHtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0XHQvLyBBdHRyYWN0aW9uIC8gQ29oZXNpb24gLSBtb3ZlIGNsb3NlclxuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0XHRmbG9hdCB0aHJlc2hEZWx0YSA9IDEuMCAtIGFsaWdubWVudFRocmVzaDtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdFx0ZmxvYXQgYWRqdXN0ZWRQZXJjZW50O1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0XHRpZiggdGhyZXNoRGVsdGEgPT0gMC4gKSBhZGp1c3RlZFBlcmNlbnQgPSAxLjtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHRcdFx0ZWxzZSBhZGp1c3RlZFBlcmNlbnQgPSAoIHBlcmNlbnQgLSBhbGlnbm1lbnRUaHJlc2ggKSAvIHRocmVzaERlbHRhO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHRcdGYgPSAoIDAuNSAtICggY29zKCBhZGp1c3RlZFBlcmNlbnQgKiBQSV8yICkgKiAtMC41ICsgMC41ICkgKSAqIGRlbHRhO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdFx0XHRcdHZlbG9jaXR5ICs9IG5vcm1hbGl6ZSggZGlyICkgKiBmO1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdFx0fVxuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdH1cbicgKwogICAgICAgICAgJ1x0XHRcdFx0fVxuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdC8vIHRoaXMgbWFrZSB0ZW5kcyB0byBmbHkgYXJvdW5kIHRoYW4gZG93biBvciB1cFxuJyArCiAgICAgICAgICAnXHRcdFx0XHQvLyBpZiAodmVsb2NpdHkueSA+IDAuKSB2ZWxvY2l0eS55ICo9ICgxLiAtIDAuMiAqIGRlbHRhKTtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHQvLyBTcGVlZCBMaW1pdHNcbicgKwogICAgICAgICAgJ1x0XHRcdFx0aWYgKCBsZW5ndGgoIHZlbG9jaXR5ICkgPiBsaW1pdCApIHtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0XHR2ZWxvY2l0eSA9IG5vcm1hbGl6ZSggdmVsb2NpdHkgKSAqIGxpbWl0O1xuJyArCiAgICAgICAgICAnXHRcdFx0XHR9XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVsb2NpdHksIDEuMCApO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHR9XG4nLCBkdFZlbG9jaXR5KTsKICAgICAgICBwb3NpdGlvblZhcmlhYmxlID0gZ3B1Q29tcHV0ZS5hZGRWYXJpYWJsZSgidGV4dHVyZVBvc2l0aW9uIiwKICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHRpbWU7XG4nICsKICAgICAgICAgICdcdFx0XHR1bmlmb3JtIGZsb2F0IGRlbHRhO1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHR2b2lkIG1haW4oKVx0e1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uLnh5O1xuJyArCiAgICAgICAgICAnXHRcdFx0XHR2ZWM0IHRtcFBvcyA9IHRleHR1cmUyRCggdGV4dHVyZVBvc2l0aW9uLCB1diApO1xuJyArCiAgICAgICAgICAnXHRcdFx0XHR2ZWMzIHBvc2l0aW9uID0gdG1wUG9zLnh5ejtcbicgKwogICAgICAgICAgJ1x0XHRcdFx0dmVjMyB2ZWxvY2l0eSA9IHRleHR1cmUyRCggdGV4dHVyZVZlbG9jaXR5LCB1diApLnh5ejtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRmbG9hdCBwaGFzZSA9IHRtcFBvcy53O1xuJyArCiAgICAgICAgICAnXG4nICsKICAgICAgICAgICdcdFx0XHRcdHBoYXNlID0gbW9kKCAoIHBoYXNlICsgZGVsdGEgK1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdGxlbmd0aCggdmVsb2NpdHkueHogKSAqIGRlbHRhICogMy4gK1xuJyArCiAgICAgICAgICAnXHRcdFx0XHRcdG1heCggdmVsb2NpdHkueSwgMC4wICkgKiBkZWx0YSAqIDYuICksIDYyLjgzICk7XG4nICsKICAgICAgICAgICdcbicgKwogICAgICAgICAgJ1x0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcG9zaXRpb24gKyB2ZWxvY2l0eSAqIGRlbHRhICogMTUuICwgcGhhc2UgKTtcbicgKwogICAgICAgICAgJ1xuJyArCiAgICAgICAgICAnXHRcdFx0fScKCiAgICAgICAgICAsIGR0UG9zaXRpb24pOwoKICAgICAgICBncHVDb21wdXRlLnNldFZhcmlhYmxlRGVwZW5kZW5jaWVzKHZlbG9jaXR5VmFyaWFibGUsIFtwb3NpdGlvblZhcmlhYmxlLCB2ZWxvY2l0eVZhcmlhYmxlXSk7CiAgICAgICAgZ3B1Q29tcHV0ZS5zZXRWYXJpYWJsZURlcGVuZGVuY2llcyhwb3NpdGlvblZhcmlhYmxlLCBbcG9zaXRpb25WYXJpYWJsZSwgdmVsb2NpdHlWYXJpYWJsZV0pOwoKICAgICAgICBwb3NpdGlvblVuaWZvcm1zID0gcG9zaXRpb25WYXJpYWJsZS5tYXRlcmlhbC51bmlmb3JtczsKICAgICAgICB2ZWxvY2l0eVVuaWZvcm1zID0gdmVsb2NpdHlWYXJpYWJsZS5tYXRlcmlhbC51bmlmb3JtczsKCiAgICAgICAgcG9zaXRpb25Vbmlmb3Jtc1sidGltZSJdID0ge3ZhbHVlOiAwLjB9OwogICAgICAgIHBvc2l0aW9uVW5pZm9ybXNbImRlbHRhIl0gPSB7dmFsdWU6IDAuMH07CiAgICAgICAgdmVsb2NpdHlVbmlmb3Jtc1sidGltZSJdID0ge3ZhbHVlOiAxLjB9OwogICAgICAgIHZlbG9jaXR5VW5pZm9ybXNbImRlbHRhIl0gPSB7dmFsdWU6IDAuMH07CiAgICAgICAgdmVsb2NpdHlVbmlmb3Jtc1sidGVzdGluZyJdID0ge3ZhbHVlOiAxLjB9OwogICAgICAgIHZlbG9jaXR5VW5pZm9ybXNbInNlcGFyYXRpb25EaXN0YW5jZSJdID0ge3ZhbHVlOiAxLjB9OwogICAgICAgIHZlbG9jaXR5VW5pZm9ybXNbImFsaWdubWVudERpc3RhbmNlIl0gPSB7dmFsdWU6IDEuMH07CiAgICAgICAgdmVsb2NpdHlVbmlmb3Jtc1siY29oZXNpb25EaXN0YW5jZSJdID0ge3ZhbHVlOiAxLjB9OwogICAgICAgIHZlbG9jaXR5VW5pZm9ybXNbImZyZWVkb21GYWN0b3IiXSA9IHt2YWx1ZTogMS4wfTsKICAgICAgICB2ZWxvY2l0eVVuaWZvcm1zWyJwcmVkYXRvciJdID0ge3ZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMygpfTsKICAgICAgICB2ZWxvY2l0eVZhcmlhYmxlLm1hdGVyaWFsLmRlZmluZXMuQk9VTkRTID0gQk9VTkRTLnRvRml4ZWQoMik7CgogICAgICAgIHZlbG9jaXR5VmFyaWFibGUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZzsKICAgICAgICB2ZWxvY2l0eVZhcmlhYmxlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7CiAgICAgICAgcG9zaXRpb25WYXJpYWJsZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nOwogICAgICAgIHBvc2l0aW9uVmFyaWFibGUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZzsKCiAgICAgICAgY29uc3QgZXJyb3IgPSBncHVDb21wdXRlLmluaXQoKTsKCiAgICAgICAgaWYgKGVycm9yICE9PSBudWxsKSB7CgogICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7CgogICAgICAgIH0KCiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGluaXRCaXJkcygpIHsKICAgICAgICBjb25zdCBnZW9tZXRyeSA9IEJpcmRHZW9tZXRyeTsKICAgICAgICBjb25zdCBtID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHsKICAgICAgICAgIHZlcnRleENvbG9yczogdHJ1ZSwKICAgICAgICAgIGZsYXRTaGFkaW5nOiB0cnVlLAogICAgICAgICAgcm91Z2huZXNzOiAxLAogICAgICAgICAgbWV0YWxuZXNzOiAwCiAgICAgICAgfSk7CgogICAgICAgIG0ub25CZWZvcmVDb21waWxlID0gKHNoYWRlcikgPT4gewogICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnRleHR1cmVQb3NpdGlvbiA9IHt2YWx1ZTogbnVsbH07CiAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudGV4dHVyZVZlbG9jaXR5ID0ge3ZhbHVlOiBudWxsfTsKICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy50ZXh0dXJlQW5pbWF0aW9uID0ge3ZhbHVlOiB0ZXh0dXJlQW5pbWF0aW9ufTsKICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy50aW1lID0ge3ZhbHVlOiAxLjB9OwogICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnNpemUgPSB7dmFsdWU6IDAuM307CiAgICAgICAgICBzaGFkZXIudW5pZm9ybXMuZGVsdGEgPSB7dmFsdWU6IDAuMH07CgogICAgICAgICAgbGV0IHRva2VuID0gJyNkZWZpbmUgU1RBTkRBUkQnOwoKICAgICAgICAgIGxldCBpbnNlcnQgPSAvKiBnbHNsICovYAoJCQkJCQlhdHRyaWJ1dGUgdmVjNCByZWZlcmVuY2U7CgkJCQkJCWF0dHJpYnV0ZSB2ZWM0IHNlZWRzOwoJCQkJCQlhdHRyaWJ1dGUgdmVjMyBiaXJkQ29sb3I7CgkJCQkJCXVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVQb3NpdGlvbjsKCQkJCQkJdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVZlbG9jaXR5OwoJCQkJCQl1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlQW5pbWF0aW9uOwoJCQkJCQl1bmlmb3JtIGZsb2F0IHNpemU7CgkJCQkJCXVuaWZvcm0gZmxvYXQgdGltZTsKCQkJCQlgOwoKICAgICAgICAgIHNoYWRlci52ZXJ0ZXhTaGFkZXIgPSBzaGFkZXIudmVydGV4U2hhZGVyLnJlcGxhY2UodG9rZW4sIHRva2VuICsgaW5zZXJ0KTsKCiAgICAgICAgICB0b2tlbiA9ICcjaW5jbHVkZSA8YmVnaW5fdmVydGV4Pic7CgogICAgICAgICAgaW5zZXJ0ID0gLyogZ2xzbCAqL2AKCQkJCQkJdmVjNCB0bXBQb3MgPSB0ZXh0dXJlMkQoIHRleHR1cmVQb3NpdGlvbiwgcmVmZXJlbmNlLnh5ICk7CgoJCQkJCQl2ZWMzIHBvcyA9IHRtcFBvcy54eXo7CgkJCQkJCXZlYzMgdmVsb2NpdHkgPSBub3JtYWxpemUodGV4dHVyZTJEKCB0ZXh0dXJlVmVsb2NpdHksIHJlZmVyZW5jZS54eSApLnh5eik7CgkJCQkJCXZlYzMgYW5pUG9zID0gdGV4dHVyZTJEKCB0ZXh0dXJlQW5pbWF0aW9uLCB2ZWMyKCByZWZlcmVuY2UueiwgbW9kKCB0aW1lICsgKCBzZWVkcy54ICkgKiAoICggMC4wMDA0ICsgc2VlZHMueSAvIDEwMDAwLjApICsgbm9ybWFsaXplKCB2ZWxvY2l0eSApIC8gMjAwMDAuMCApLCByZWZlcmVuY2UudyApICkgKS54eXo7CgkJCQkJCXZlYzMgbmV3UG9zaXRpb24gPSBwb3NpdGlvbjsKCgkJCQkJCW5ld1Bvc2l0aW9uID0gbWF0MyggbW9kZWxNYXRyaXggKSAqICggbmV3UG9zaXRpb24gKyBhbmlQb3MgKTsKCQkJCQkJbmV3UG9zaXRpb24gKj0gc2l6ZSArIHNlZWRzLnkgKiBzaXplICogMC4yOwoKCQkJCQkJdmVsb2NpdHkueiAqPSAtMS47CgkJCQkJCWZsb2F0IHh6ID0gbGVuZ3RoKCB2ZWxvY2l0eS54eiApOwoJCQkJCQlmbG9hdCB4eXogPSAxLjsKCQkJCQkJZmxvYXQgeCA9IHNxcnQoIDEuIC0gdmVsb2NpdHkueSAqIHZlbG9jaXR5LnkgKTsKCgkJCQkJCWZsb2F0IGNvc3J5ID0gdmVsb2NpdHkueCAvIHh6OwoJCQkJCQlmbG9hdCBzaW5yeSA9IHZlbG9jaXR5LnogLyB4ejsKCgkJCQkJCWZsb2F0IGNvc3J6ID0geCAvIHh5ejsKCQkJCQkJZmxvYXQgc2lucnogPSB2ZWxvY2l0eS55IC8geHl6OwoKCQkJCQkJbWF0MyBtYXR5ID0gIG1hdDMoIGNvc3J5LCAwLCAtc2lucnksIDAgICAgLCAxLCAwICAgICAsIHNpbnJ5LCAwLCBjb3NyeSApOwoJCQkJCQltYXQzIG1hdHogPSAgbWF0MyggY29zcnogLCBzaW5yeiwgMCwgLXNpbnJ6LCBjb3NyeiwgMCwgMCAgICAgLCAwICAgICwgMSApOwoKCQkJCQkJbmV3UG9zaXRpb24gPSAgbWF0eSAqIG1hdHogKiBuZXdQb3NpdGlvbjsKCQkJCQkJbmV3UG9zaXRpb24gKz0gcG9zOwoKCQkJCQkJdmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMoIG5ld1Bvc2l0aW9uICk7CgkJCQkJYDsKCiAgICAgICAgICBzaGFkZXIudmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlci5yZXBsYWNlKHRva2VuLCBpbnNlcnQpOwogICAgICAgICAgbWF0ZXJpYWxTaGFkZXIgPSBzaGFkZXI7CiAgICAgICAgfTsKCiAgICAgICAgYmlyZE1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbSk7CiAgICAgICAgYmlyZE1lc2gucm90YXRpb24ueSA9IE1hdGguUEkgLyAyOwogICAgICAgIGJpcmRNZXNoLnBvc2l0aW9uLnggPSAxMzAwOwogICAgICAgIGJpcmRNZXNoLnBvc2l0aW9uLnogPSAtMjQwMDsKICAgICAgICBiaXJkTWVzaC5wb3NpdGlvbi55ID0gMzAwOwoKICAgICAgICBiaXJkTWVzaC5jYXN0U2hhZG93ID0gdHJ1ZTsKICAgICAgICBiaXJkTWVzaC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTsKICAgICAgICBzY2VuZS5hZGQoYmlyZE1lc2gpOwogICAgICB9CgogICAgICBmdW5jdGlvbiBmaWxsUG9zaXRpb25UZXh0dXJlKHRleHR1cmUpIHsKICAgICAgICBjb25zdCB0aGVBcnJheSA9IHRleHR1cmUuaW1hZ2UuZGF0YTsKICAgICAgICBmb3IgKGxldCBrID0gMCwga2wgPSB0aGVBcnJheS5sZW5ndGg7IGsgPCBrbDsgayArPSA0KSB7CiAgICAgICAgICBjb25zdCB4ID0gTWF0aC5yYW5kb20oKSAqIEJPVU5EUyAtIEJPVU5EU19IQUxGOwogICAgICAgICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCkgKiBCT1VORFMgLSBCT1VORFNfSEFMRjsKICAgICAgICAgIGNvbnN0IHogPSBNYXRoLnJhbmRvbSgpICogQk9VTkRTIC0gQk9VTkRTX0hBTEY7CgogICAgICAgICAgdGhlQXJyYXlbayArIDBdID0geDsKICAgICAgICAgIHRoZUFycmF5W2sgKyAxXSA9IHk7CiAgICAgICAgICB0aGVBcnJheVtrICsgMl0gPSB6OwogICAgICAgICAgdGhlQXJyYXlbayArIDNdID0gMTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGZpbGxWZWxvY2l0eVRleHR1cmUodGV4dHVyZSkgewogICAgICAgIGNvbnN0IHRoZUFycmF5ID0gdGV4dHVyZS5pbWFnZS5kYXRhOwogICAgICAgIGZvciAobGV0IGsgPSAwLCBrbCA9IHRoZUFycmF5Lmxlbmd0aDsgayA8IGtsOyBrICs9IDQpIHsKICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJhbmRvbSgpIC0gMC41OwogICAgICAgICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCkgLSAwLjU7CiAgICAgICAgICBjb25zdCB6ID0gTWF0aC5yYW5kb20oKSAtIDAuNTsKICAgICAgICAgIHRoZUFycmF5W2sgKyAwXSA9IHggKiAxMDsKICAgICAgICAgIHRoZUFycmF5W2sgKyAxXSA9IHkgKiAxMDsKICAgICAgICAgIHRoZUFycmF5W2sgKyAyXSA9IHogKiAxMDsKICAgICAgICAgIHRoZUFycmF5W2sgKyAzXSA9IDE7CiAgICAgICAgfQogICAgICB9CgoKICAgICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkgewogICAgICAgIGlmIChldmVudC5pc1ByaW1hcnkgPT09IGZhbHNlKSByZXR1cm47CiAgICAgICAgbW91c2VYID0gZXZlbnQuY2xpZW50WCAtIHdpbmRvd0hhbGZYOwogICAgICAgIG1vdXNlWSA9IGV2ZW50LmNsaWVudFkgLSB3aW5kb3dIYWxmWTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gY3JlYXRlVGV4dCgpIHsKICAgICAgICB0ZXh0R2VvID0gbmV3IFRIUkVFLlRleHRHZW9tZXRyeSh0ZXh0LCB7CiAgICAgICAgICBmb250OiBmb250LAogICAgICAgICAgc2l6ZTogc2l6ZSwKICAgICAgICAgIGhlaWdodDogaGVpZ2h0LAogICAgICAgICAgY3VydmVTZWdtZW50czogY3VydmVTZWdtZW50cywKICAgICAgICAgIGJldmVsVGhpY2tuZXNzOiBiZXZlbFRoaWNrbmVzcywKICAgICAgICAgIGJldmVsU2l6ZTogYmV2ZWxTaXplLAogICAgICAgICAgYmV2ZWxFbmFibGVkOiB0cnVlCiAgICAgICAgfSk7CgogICAgICAgIHRleHRHZW8uY29tcHV0ZUJvdW5kaW5nQm94KCk7CiAgICAgICAgdGV4dEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpOwoKICAgICAgICBjb25zdCBjZW50ZXJPZmZzZXQgPSAtMC41ICogKHRleHRHZW8uYm91bmRpbmdCb3gubWF4LnggLSB0ZXh0R2VvLmJvdW5kaW5nQm94Lm1pbi54KTsKCiAgICAgICAgaWYgKG1pcnJvcikgewogICAgICAgICAgdGV4dE1lc2gyID0gbmV3IFRIUkVFLk1lc2godGV4dEdlbywgbWF0ZXJpYWwpOwogICAgICAgICAgdGV4dE1lc2gyLnBvc2l0aW9uLnggPSBjZW50ZXJPZmZzZXQ7CiAgICAgICAgICB0ZXh0TWVzaDIucG9zaXRpb24ueSA9IC1ob3ZlcjsKICAgICAgICAgIHRleHRNZXNoMi5wb3NpdGlvbi56ID0gaGVpZ2h0OwogICAgICAgICAgdGV4dE1lc2gyLnJvdGF0aW9uLnggPSBNYXRoLlBJOwogICAgICAgICAgdGV4dE1lc2gyLnJvdGF0aW9uLnkgPSBNYXRoLlBJICogMjsKICAgICAgICAgIGdyb3VwLmFkZCh0ZXh0TWVzaDIpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7CiAgICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0OwogICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7CiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHsKICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7CiAgICAgICAgZ3JvdXAucG9zaXRpb24ueCA9IC0yMjc7CiAgICAgICAgZ3JvdXAucG9zaXRpb24ueSA9IDE4OwogICAgICAgIGdyb3VwLnBvc2l0aW9uLnogPSAtNjAwOwogICAgICAgIGdyb3VwLnJvdGF0aW9uLnkgPSA2LjA7CiAgICAgICAgZ3JvdXAucm90YXRpb24ueCA9IDYwMC4wMjsKICAgICAgICBncm91cC5yb3RhdGlvbi56ID0gMjE5Ljk7CiAgICAgICAgcmVuZGVyKCk7CiAgICAgIH0KCgogICAgICBsZXQgcmFkaXVzID0gMjcwMDsKICAgICAgbGV0IHRoZXRhID0gODsKCgogICAgICBmdW5jdGlvbiByZW5kZXIoKSB7CiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7CiAgICAgICAgY29uc3QgdGltZSA9IG5vdyAqIDAuMDAwNTsKICAgICAgICBmb3IgKGxldCBtZXNoIG9mIG1lc2hlcykgewogICAgICAgICAgbW92ZSh0aW1lLCBtZXNoKTsKICAgICAgICB9CiAgICAgICAgd2F0ZXIubWF0ZXJpYWwudW5pZm9ybXNbJ3RpbWUnXS52YWx1ZSArPSAxLjAgLyA2MC4wOwoKICAgICAgICBpZiAodGhldGEgPCAzMy43KSB7CiAgICAgICAgICB0aGV0YSArPSAwLjE7CiAgICAgICAgICByYWRpdXMgLT0gMTA7CgogICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggPSByYWRpdXMgKiBNYXRoLnNpbihUSFJFRS5NYXRoVXRpbHMuZGVnVG9SYWQodGhldGEpKSAtIDQ1OwogICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgPSByYWRpdXMgLyAzICogTWF0aC5zaW4oVEhSRUUuTWF0aFV0aWxzLmRlZ1RvUmFkKHRoZXRhKSk7CiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IHJhZGl1cyAqIE1hdGguY29zKFRIUkVFLk1hdGhVdGlscy5kZWdUb1JhZCh0aGV0YSkpOwogICAgICAgIH0KCgogICAgICAgIC8vY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7CgogICAgICAgIGxldCBkZWx0YSA9IChub3cgLSBsYXN0KSAvIDEwMDA7CiAgICAgICAgaWYgKGRlbHRhID4gMSkgZGVsdGEgPSAxOyAvLyBzYWZldHkgY2FwIG9uIGxhcmdlIGRlbHRhcwogICAgICAgIGxhc3QgPSBub3c7CiAgICAgICAgcG9zaXRpb25Vbmlmb3Jtc1sidGltZSJdLnZhbHVlID0gbm93OwogICAgICAgIHBvc2l0aW9uVW5pZm9ybXNbImRlbHRhIl0udmFsdWUgPSBkZWx0YTsKICAgICAgICB2ZWxvY2l0eVVuaWZvcm1zWyJ0aW1lIl0udmFsdWUgPSBub3c7CiAgICAgICAgdmVsb2NpdHlVbmlmb3Jtc1siZGVsdGEiXS52YWx1ZSA9IGRlbHRhOwogICAgICAgIGlmIChtYXRlcmlhbFNoYWRlcikgbWF0ZXJpYWxTaGFkZXIudW5pZm9ybXNbInRpbWUiXS52YWx1ZSA9IG5vdyAvIDEwMDA7CiAgICAgICAgaWYgKG1hdGVyaWFsU2hhZGVyKSBtYXRlcmlhbFNoYWRlci51bmlmb3Jtc1siZGVsdGEiXS52YWx1ZSA9IGRlbHRhOwoKICAgICAgICB2ZWxvY2l0eVVuaWZvcm1zWyJwcmVkYXRvciJdLnZhbHVlLnNldCgwLjUgKiBtb3VzZVggLyB3aW5kb3dIYWxmWCwgLTAuNSAqIG1vdXNlWSAvIHdpbmRvd0hhbGZZLCAwKTsKCiAgICAgICAgbW91c2VYID0gMTAwMDA7CiAgICAgICAgbW91c2VZID0gMTAwMDA7CgogICAgICAgIGdwdUNvbXB1dGUuY29tcHV0ZSgpOwogICAgICAgIGlmIChtYXRlcmlhbFNoYWRlcikgbWF0ZXJpYWxTaGFkZXIudW5pZm9ybXNbInRleHR1cmVQb3NpdGlvbiJdLnZhbHVlID0gZ3B1Q29tcHV0ZS5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KHBvc2l0aW9uVmFyaWFibGUpLnRleHR1cmU7CiAgICAgICAgaWYgKG1hdGVyaWFsU2hhZGVyKSBtYXRlcmlhbFNoYWRlci51bmlmb3Jtc1sidGV4dHVyZVZlbG9jaXR5Il0udmFsdWUgPSBncHVDb21wdXRlLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQodmVsb2NpdHlWYXJpYWJsZSkudGV4dHVyZTsKCgogICAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gbW92ZSh0aW1lLCBtZXNoKSB7CiAgICAgICAgbWVzaC5vYmoucG9zaXRpb24ueSA9IE1hdGguc2luKHRpbWUgKyBtZXNoLnBvcy54KSAqIDUgKyBtZXNoLnBvcy55OwogICAgICAgIG1lc2gub2JqLnBvc2l0aW9uLnggPSBtZXNoLnBvcy54OwogICAgICAgIG1lc2gub2JqLnBvc2l0aW9uLnogPSBtZXNoLnBvcy56OwogICAgICAgIG1lc2gub2JqLnJvdGF0aW9uLnggPSBtZXNoLnJvdC54ICogdGltZTsKICAgICAgICBtZXNoLm9iai5yb3RhdGlvbi56ID0gbWVzaC5yb3QueiAqIHRpbWU7CiAgICAgIH0KICAgIH0KICB9Cg=="},{"version":3,"sources":["subsystem.vue"],"names":[],"mappings":";;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"subsystem.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class='app-container'>\n    <div id=\"container\">\n\n    </div>\n  </div>\n</template>\n\n<script>\n  import * as THREE from 'three';\n  import {OrbitControls} from 'three/examples/jsm/controls/OrbitControls.js';\n  import {Water} from 'three/examples/jsm/objects/Water.js';\n  import {Sky} from 'three/examples/jsm/objects/Sky.js';\n  import {TTFLoader} from 'three/examples/jsm/loaders/TTFLoader.js';\n  import {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';\n  import {GPUComputationRenderer} from 'three/examples/jsm/misc/GPUComputationRenderer.js';\n\n  export default {\n    name: \"first\",\n    methods: {},\n    mounted() {\n      /* TEXTURE WIDTH FOR SIMULATION */\n      const WIDTH = 2;\n      const BIRDS = 4;\n\n      /* BAKE ANIMATION INTO TEXTURE and CREATE GEOMETRY FROM BASE MODEL */\n      const BirdGeometry = new THREE.BufferGeometry();\n      let textureAnimation, durationAnimation, birdMesh, materialShader, vertexPerBird;\n\n      function nextPowerOf2(n) {\n        return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));\n      }\n\n      Math.lerp = function (value1, value2, amount) {\n        amount = Math.max(Math.min(amount, 1), 0);\n        return value1 + (value2 - value1) * amount;\n      };\n\n      const gltfs = ['files/glbs/Parrot.glb', 'files/glbs/Flamingo.glb'];\n      const selectModel = Math.floor(Math.random() * gltfs.length);\n      new GLTFLoader().load(gltfs[selectModel], function (gltf) {\n        const animations = gltf.animations;\n        durationAnimation = Math.round(animations[0].duration * 60);\n        const birdGeo = gltf.scene.children[0].geometry;\n        const morphAttributes = birdGeo.morphAttributes.position;\n        const tHeight = nextPowerOf2(durationAnimation);\n        const tWidth = nextPowerOf2(birdGeo.getAttribute('position').count);\n        vertexPerBird = birdGeo.getAttribute('position').count;\n        const tData = new Float32Array(3 * tWidth * tHeight);\n\n        for (let i = 0; i < tWidth; i++) {\n          for (let j = 0; j < tHeight; j++) {\n            const offset = j * tWidth * 3;\n            const curMorph = Math.floor(j / durationAnimation * morphAttributes.length);\n            const nextMorph = (Math.floor(j / durationAnimation * morphAttributes.length) + 1) % morphAttributes.length;\n            const lerpAmount = j / durationAnimation * morphAttributes.length % 1;\n\n            if (j < durationAnimation) {\n              let d0, d1;\n              d0 = morphAttributes[curMorph].array[i * 3];\n              d1 = morphAttributes[nextMorph].array[i * 3];\n              if (d0 !== undefined && d1 !== undefined) tData[offset + i * 3] = Math.lerp(d0, d1, lerpAmount);\n              d0 = morphAttributes[curMorph].array[i * 3 + 1];\n              d1 = morphAttributes[nextMorph].array[i * 3 + 1];\n              if (d0 !== undefined && d1 !== undefined) tData[offset + i * 3 + 1] = Math.lerp(d0, d1, lerpAmount);\n              d0 = morphAttributes[curMorph].array[i * 3 + 2];\n              d1 = morphAttributes[nextMorph].array[i * 3 + 2];\n              if (d0 !== undefined && d1 !== undefined) tData[offset + i * 3 + 2] = Math.lerp(d0, d1, lerpAmount);\n            }\n          }\n        }\n\n        textureAnimation = new THREE.DataTexture(tData, tWidth, tHeight, THREE.RGBFormat, THREE.FloatType);\n        textureAnimation.needsUpdate = true;\n\n        const vertices = [], color = [], reference = [], seeds = [], indices = [];\n        const totalVertices = birdGeo.getAttribute('position').count * 3 * BIRDS;\n        for (let i = 0; i < totalVertices; i++) {\n          const bIndex = i % (birdGeo.getAttribute('position').count * 3);\n          vertices.push(birdGeo.getAttribute('position').array[bIndex]);\n          color.push(birdGeo.getAttribute('color').array[bIndex]);\n        }\n\n        let r = Math.random();\n        for (let i = 0; i < birdGeo.getAttribute('position').count * BIRDS; i++) {\n          const bIndex = i % (birdGeo.getAttribute('position').count);\n          const bird = Math.floor(i / birdGeo.getAttribute('position').count);\n          if (bIndex === 0) r = Math.random();\n          const j = ~~bird;\n          const x = (j % WIDTH) / WIDTH;\n          const y = ~~(j / WIDTH) / WIDTH;\n          reference.push(x, y, bIndex / tWidth, durationAnimation / tHeight);\n          seeds.push(bird, r, Math.random(), Math.random());\n        }\n\n        for (let i = 0; i < birdGeo.index.array.length * BIRDS; i++) {\n          const offset = Math.floor(i / birdGeo.index.array.length) * (birdGeo.getAttribute('position').count);\n          indices.push(birdGeo.index.array[i % birdGeo.index.array.length] + offset);\n        }\n\n        BirdGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n        BirdGeometry.setAttribute('birdColor', new THREE.BufferAttribute(new Float32Array(color), 3));\n        BirdGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(color), 3));\n        BirdGeometry.setAttribute('reference', new THREE.BufferAttribute(new Float32Array(reference), 4));\n        BirdGeometry.setAttribute('seeds', new THREE.BufferAttribute(new Float32Array(seeds), 4));\n\n        BirdGeometry.setIndex(indices);\n\n        init();\n        animate();\n\n      });\n\n\n      let container, stats;\n      let camera, scene, renderer;\n      let mouseX = 0, mouseY = 0;\n\n      let windowHalfX = window.innerWidth / 2;\n      let windowHalfY = window.innerHeight / 2;\n\n      const BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;\n\n      let last = performance.now();\n\n      let gpuCompute;\n      let velocityVariable;\n      let positionVariable;\n      let positionUniforms;\n      let velocityUniforms;\n\n      let controls, water, sun;\n      let meshes;\n      let iniMeshes = function () {\n        meshes = [\n          {\n            name: 'mesh0',\n            pos: {x: -60, y: 0, z: 60},\n            url: '#',\n            img: require('@/assets/flash/monitor.png'),\n            rot: {x: 0.1, y: 0.2, z: 0.5}\n          },\n\n          {\n            name: 'mesh2',\n            pos: {x: -0, y: 0, z: 40},\n            url: '/reservoir',\n            img: require('@/assets/flash/manage.png'),\n            rot: {x: 0.3, y: 0.2, z: 0.3}\n          },\n\n          {\n            name: 'mesh4',\n            pos: {x: 60, y: 0, z: 40},\n            url: '#',\n            img: require('@/assets/flash/apprise.png'),\n            rot: {x: 0.5, y: 0.2, z: 0.1}\n          },\n        ];\n      }();\n\n\n      let group, textMesh1, textMesh2, textGeo, material;\n\n      let text = '滕州市数字水库监管平台';\n      const height = 20,\n        size = 70,\n        hover = 30,\n        curveSegments = 4,\n        bevelThickness = 2,\n        bevelSize = 1.5;\n\n      let font = null;\n      const mirror = true;\n\n\n      let inArea = false;\n      let currentIndex = null;\n\n\n      addTouch();\n\n      function addTouch() {\n        function onMouseMove(event) {\n          let intersect = getIntersect();\n          if (intersect) {\n            document.body.style.cursor = \"pointer\";\n            let mesh = meshes[intersect.object.index];\n            currentIndex = intersect.object.index;\n            mesh.rot.x = 0;\n            mesh.rot.z = 0;\n            mesh.rot.y = 0;\n            mesh.pos.y = 5;\n            inArea = true;\n            render();\n          } else {\n            if (inArea) {\n              inArea = false;\n              meshes[currentIndex].rot.x = (currentIndex + 1) * 0.1;\n              meshes[currentIndex].rot.y = 0.2;\n              meshes[currentIndex].rot.z = (meshes.length - currentIndex - 1) * 0.1;\n              meshes[currentIndex].pos.y = 0;\n              render();\n            }\n            document.body.style.cursor = \"default\";\n          }\n        }\n\n        function onMouseClick(event) {\n          let intersect = getIntersect();\n          if (intersect) {\n            window.location.href = findMesh(intersect.object.position.x).url;\n          }\n        }\n\n        function findMesh(x) {\n          for (let mesh of meshes) {\n            if (x === mesh.pos.x) {\n              return mesh;\n            }\n          }\n        }\n\n        function getIntersect() {\n          //声明射线和mouse变量\n          let raycaster = new THREE.Raycaster();\n          let mouse = new THREE.Vector2();\n\n          //通过鼠标点击的位置计算出射线所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.\n          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n          //根据在屏幕的二维位置以及相机的矩阵更新射线的位置\n          raycaster.setFromCamera(mouse, camera);\n\n          // 获取射线直线和所有模型相交的数组集合\n          let intersects = raycaster.intersectObjects(scene.children, true); //增加第二个参数，可以遍历子子孙孙对象\n          //判断当前数组是否为空,不为空则获取最近的的模型，将其颜色修改为红色\n          if (intersects.length > 2) {\n            for (let intersect of intersects) {\n              if (intersect.object instanceof THREE.Mesh && (intersect.object.index >= 0)) {\n                return intersect;\n              }\n            }\n          }\n        }\n\n        document.addEventListener(\"click\", onMouseClick, false);\n        document.addEventListener(\"mousemove\", onMouseMove, false);\n      }\n\n      function init() {\n        container = document.getElementById('container');\n\n        renderer = new THREE.WebGLRenderer();\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.toneMapping = THREE.ACESFilmicToneMapping;\n        container.appendChild(renderer.domElement);\n        //\n\n        scene = new THREE.Scene();\n\n        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 20000);\n        camera.position.set(30, 30, 100);\n        //\n\n        sun = new THREE.Vector3();\n\n        // Water\n        const waterGeometry = new THREE.PlaneGeometry(10000, 10000);\n        water = new Water(\n          waterGeometry,\n          {\n            textureWidth: 512,\n            textureHeight: 512,\n            waterNormals: new THREE.TextureLoader().load(require('@/assets/flash/waternormals.jpg'), function (texture) {\n              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n            }),\n            sunDirection: new THREE.Vector3(),\n            sunColor: 0xffffff,\n            waterColor: 0x001e0f,\n            distortionScale: 10,\n            fog: scene.fog !== undefined\n          }\n        );\n        water.rotation.x = -Math.PI / 2;\n        scene.add(water);\n\n        // Skybox\n        const sky = new Sky();\n        sky.scale.setScalar(10000);\n        scene.add(sky);\n\n        const skyUniforms = sky.material.uniforms;\n        skyUniforms['turbidity'].value = 10;\n        skyUniforms['rayleigh'].value = 9;\n        skyUniforms['mieCoefficient'].value = 0.005;\n        skyUniforms['mieDirectionalG'].value = 0.8;\n\n        const parameters = {\n          elevation: ((12 - Math.abs(new Date().getHours() + new Date().getMinutes() / 60 - 12)) * 40 / 12 - 20) * 2,\n          azimuth: (12 - new Date().getHours() - new Date().getMinutes() / 60) * 10 - 170\n        };\n\n        const pmremGenerator = new THREE.PMREMGenerator(renderer);\n\n        let updateSun = function () {\n          const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);\n          const theta = THREE.MathUtils.degToRad(parameters.azimuth);\n\n          sun.setFromSphericalCoords(1, phi, theta);\n          sky.material.uniforms['sunPosition'].value.copy(sun);\n          water.material.uniforms['sunDirection'].value.copy(sun).normalize();\n          scene.environment = pmremGenerator.fromScene(sky).texture;\n        }();\n\n        const geometry = new THREE.BoxGeometry(20, 20, 20);\n\n        for (let i = 0; i < meshes.length; i++) {\n          const texture = new THREE.TextureLoader().load(meshes[i].img);\n          const material = new THREE.MeshStandardMaterial({map: texture});\n\n          let m = new THREE.Mesh(geometry, material);\n          m.index = i;\n          scene.add(m);\n          meshes[i].obj = m;\n        }\n\n        const geo = new THREE.BoxGeometry(30, 30, 30);\n        const tex = new THREE.TextureLoader().load(require('@/assets/logo/water.png'));\n        const mat = new THREE.MeshStandardMaterial({map: tex});\n        let iconMesh = new THREE.Mesh(geo, mat);\n        iconMesh.position.x = -800;\n        iconMesh.position.y = 88;\n        iconMesh.position.z = -500;\n        iconMesh.rotation.y = 7.24;\n        iconMesh.rotation.x = 9.5;\n        iconMesh.rotation.z = 9.4;\n        scene.add(iconMesh);   //版权问题，暂时不开启\n\n        controls = new OrbitControls(camera, renderer.domElement);\n        controls.maxPolarAngle = Math.PI * 0.495;\n        controls.target.set(0, 10, 0);\n        controls.minDistance = 50.0;\n        controls.maxDistance = 4800.0;\n        controls.update();\n\n        //\n        const dirLight = new THREE.DirectionalLight(0xffffff, 0.125);\n        dirLight.position.set(0, 0, 1).normalize();\n        scene.add(dirLight);\n\n        const pointLight = new THREE.PointLight(0xffffff, 1.5);\n        pointLight.position.set(0, 200, 90);\n        pointLight.color.setHSL(0.1, 1, 0.3);\n        scene.add(pointLight);\n\n        material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading: true});\n        //\n        group = new THREE.Group();\n        group.position.y = 100;\n\n        scene.add(group);\n\n        const loader = new TTFLoader();\n\n        loader.load(require('@/assets/flash/title.ttf'), function (json) {\n          font = new THREE.Font(json);\n          createText();\n        });\n\n\n        camera.updateMatrixWorld();\n\n        initComputeRenderer();\n        initBirds();\n        container.style.touchAction = 'none';\n        container.addEventListener('pointermove', onPointerMove);\n\n        window.addEventListener('resize', onWindowResize);\n      }\n\n      function initComputeRenderer() {\n        gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n\n        const dtPosition = gpuCompute.createTexture();\n        const dtVelocity = gpuCompute.createTexture();\n        fillPositionTexture(dtPosition);\n        fillVelocityTexture(dtVelocity);\n\n        velocityVariable = gpuCompute.addVariable(\"textureVelocity\",\n          'uniform float time;\\n' +\n          '\\t\\t\\tuniform float testing;\\n' +\n          '\\t\\t\\tuniform float delta; // about 0.016\\n' +\n          '\\t\\t\\tuniform float separationDistance; // 20\\n' +\n          '\\t\\t\\tuniform float alignmentDistance; // 40\\n' +\n          '\\t\\t\\tuniform float cohesionDistance; //\\n' +\n          '\\t\\t\\tuniform float freedomFactor;\\n' +\n          '\\t\\t\\tuniform vec3 predator;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float width = resolution.x;\\n' +\n          '\\t\\t\\tconst float height = resolution.y;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float PI = 3.141592653589793;\\n' +\n          '\\t\\t\\tconst float PI_2 = PI * 2.0;\\n' +\n          '\\t\\t\\t// const float VISION = PI * 0.55;\\n' +\n          '\\n' +\n          '\\t\\t\\tfloat zoneRadius = 40.0;\\n' +\n          '\\t\\t\\tfloat zoneRadiusSquared = 1600.0;\\n' +\n          '\\n' +\n          '\\t\\t\\tfloat separationThresh = 0.45;\\n' +\n          '\\t\\t\\tfloat alignmentThresh = 0.65;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float UPPER_BOUNDS = BOUNDS;\\n' +\n          '\\t\\t\\tconst float LOWER_BOUNDS = -UPPER_BOUNDS;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float SPEED_LIMIT = 9.0;\\n' +\n          '\\n' +\n          '\\t\\t\\tfloat rand( vec2 co ){\\n' +\n          '\\t\\t\\t\\treturn fract( sin( dot( co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );\\n' +\n          '\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\t\\t\\tvoid main() {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tzoneRadius = separationDistance + alignmentDistance + cohesionDistance;\\n' +\n          '\\t\\t\\t\\tseparationThresh = separationDistance / zoneRadius;\\n' +\n          '\\t\\t\\t\\talignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;\\n' +\n          '\\t\\t\\t\\tzoneRadiusSquared = zoneRadius * zoneRadius;\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n          '\\t\\t\\t\\tvec3 birdPosition, birdVelocity;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec3 selfPosition = texture2D( texturePosition, uv ).xyz;\\n' +\n          '\\t\\t\\t\\tvec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat dist;\\n' +\n          '\\t\\t\\t\\tvec3 dir; // direction\\n' +\n          '\\t\\t\\t\\tfloat distSquared;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat separationSquared = separationDistance * separationDistance;\\n' +\n          '\\t\\t\\t\\tfloat cohesionSquared = cohesionDistance * cohesionDistance;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat f;\\n' +\n          '\\t\\t\\t\\tfloat percent;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec3 velocity = selfVelocity;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat limit = SPEED_LIMIT;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tdir = predator * UPPER_BOUNDS - selfPosition;\\n' +\n          '\\t\\t\\t\\tdir.z = 0.;\\n' +\n          '\\t\\t\\t\\t// dir.z *= 0.6;\\n' +\n          '\\t\\t\\t\\tdist = length( dir );\\n' +\n          '\\t\\t\\t\\tdistSquared = dist * dist;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat preyRadius = 150.0;\\n' +\n          '\\t\\t\\t\\tfloat preyRadiusSq = preyRadius * preyRadius;\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// move birds away from predator\\n' +\n          '\\t\\t\\t\\tif ( dist < preyRadius ) {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\tf = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;\\n' +\n          '\\t\\t\\t\\t\\tvelocity += normalize( dir ) * f;\\n' +\n          '\\t\\t\\t\\t\\tlimit += 5.0;\\n' +\n          '\\t\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// if (testing == 0.0) {}\\n' +\n          '\\t\\t\\t\\t// if ( rand( uv + time ) < freedomFactor ) {}\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// Attract flocks to the center\\n' +\n          '\\t\\t\\t\\tvec3 central = vec3( 0., 0., 0. );\\n' +\n          '\\t\\t\\t\\tdir = selfPosition - central;\\n' +\n          '\\t\\t\\t\\tdist = length( dir );\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tdir.y *= 2.5;\\n' +\n          '\\t\\t\\t\\tvelocity -= normalize( dir ) * delta * 5.;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfor ( float y = 0.0; y < height; y++ ) {\\n' +\n          '\\t\\t\\t\\t\\tfor ( float x = 0.0; x < width; x++ ) {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tvec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\\n' +\n          '\\t\\t\\t\\t\\t\\tbirdPosition = texture2D( texturePosition, ref ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tdir = birdPosition - selfPosition;\\n' +\n          '\\t\\t\\t\\t\\t\\tdist = length( dir );\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tif ( dist < 0.0001 ) continue;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tdistSquared = dist * dist;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tif ( distSquared > zoneRadiusSquared ) continue;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tpercent = distSquared / zoneRadiusSquared;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tif ( percent < separationThresh ) { // low\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\t// Separation - Move apart for comfort\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tf = ( separationThresh / percent - 1.0 ) * delta;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tvelocity -= normalize( dir ) * f;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t} else if ( percent < alignmentThresh ) { // high\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\t// Alignment - fly the same direction\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat threshDelta = alignmentThresh - separationThresh;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat adjustedPercent = ( percent - separationThresh ) / threshDelta;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tbirdVelocity = texture2D( textureVelocity, ref ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tf = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tvelocity += normalize( birdVelocity ) * f;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t} else {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\t// Attraction / Cohesion - move closer\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat threshDelta = 1.0 - alignmentThresh;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat adjustedPercent;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tif( threshDelta == 0. ) adjustedPercent = 1.;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\telse adjustedPercent = ( percent - alignmentThresh ) / threshDelta;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tf = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tvelocity += normalize( dir ) * f;\\n' +\n          '\\t\\t\\t\\t\\t\\t}\\n' +\n          '\\t\\t\\t\\t\\t}\\n' +\n          '\\t\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// this make tends to fly around than down or up\\n' +\n          '\\t\\t\\t\\t// if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// Speed Limits\\n' +\n          '\\t\\t\\t\\tif ( length( velocity ) > limit ) {\\n' +\n          '\\t\\t\\t\\t\\tvelocity = normalize( velocity ) * limit;\\n' +\n          '\\t\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tgl_FragColor = vec4( velocity, 1.0 );\\n' +\n          '\\n' +\n          '\\t\\t\\t}\\n', dtVelocity);\n        positionVariable = gpuCompute.addVariable(\"texturePosition\",\n          'uniform float time;\\n' +\n          '\\t\\t\\tuniform float delta;\\n' +\n          '\\n' +\n          '\\t\\t\\tvoid main()\\t{\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n          '\\t\\t\\t\\tvec4 tmpPos = texture2D( texturePosition, uv );\\n' +\n          '\\t\\t\\t\\tvec3 position = tmpPos.xyz;\\n' +\n          '\\t\\t\\t\\tvec3 velocity = texture2D( textureVelocity, uv ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat phase = tmpPos.w;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tphase = mod( ( phase + delta +\\n' +\n          '\\t\\t\\t\\t\\tlength( velocity.xz ) * delta * 3. +\\n' +\n          '\\t\\t\\t\\t\\tmax( velocity.y, 0.0 ) * delta * 6. ), 62.83 );\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tgl_FragColor = vec4( position + velocity * delta * 15. , phase );\\n' +\n          '\\n' +\n          '\\t\\t\\t}'\n\n          , dtPosition);\n\n        gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n        gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n\n        positionUniforms = positionVariable.material.uniforms;\n        velocityUniforms = velocityVariable.material.uniforms;\n\n        positionUniforms[\"time\"] = {value: 0.0};\n        positionUniforms[\"delta\"] = {value: 0.0};\n        velocityUniforms[\"time\"] = {value: 1.0};\n        velocityUniforms[\"delta\"] = {value: 0.0};\n        velocityUniforms[\"testing\"] = {value: 1.0};\n        velocityUniforms[\"separationDistance\"] = {value: 1.0};\n        velocityUniforms[\"alignmentDistance\"] = {value: 1.0};\n        velocityUniforms[\"cohesionDistance\"] = {value: 1.0};\n        velocityUniforms[\"freedomFactor\"] = {value: 1.0};\n        velocityUniforms[\"predator\"] = {value: new THREE.Vector3()};\n        velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2);\n\n        velocityVariable.wrapS = THREE.RepeatWrapping;\n        velocityVariable.wrapT = THREE.RepeatWrapping;\n        positionVariable.wrapS = THREE.RepeatWrapping;\n        positionVariable.wrapT = THREE.RepeatWrapping;\n\n        const error = gpuCompute.init();\n\n        if (error !== null) {\n\n          console.error(error);\n\n        }\n\n      }\n\n      function initBirds() {\n        const geometry = BirdGeometry;\n        const m = new THREE.MeshStandardMaterial({\n          vertexColors: true,\n          flatShading: true,\n          roughness: 1,\n          metalness: 0\n        });\n\n        m.onBeforeCompile = (shader) => {\n          shader.uniforms.texturePosition = {value: null};\n          shader.uniforms.textureVelocity = {value: null};\n          shader.uniforms.textureAnimation = {value: textureAnimation};\n          shader.uniforms.time = {value: 1.0};\n          shader.uniforms.size = {value: 0.3};\n          shader.uniforms.delta = {value: 0.0};\n\n          let token = '#define STANDARD';\n\n          let insert = /* glsl */`\n\t\t\t\t\t\tattribute vec4 reference;\n\t\t\t\t\t\tattribute vec4 seeds;\n\t\t\t\t\t\tattribute vec3 birdColor;\n\t\t\t\t\t\tuniform sampler2D texturePosition;\n\t\t\t\t\t\tuniform sampler2D textureVelocity;\n\t\t\t\t\t\tuniform sampler2D textureAnimation;\n\t\t\t\t\t\tuniform float size;\n\t\t\t\t\t\tuniform float time;\n\t\t\t\t\t`;\n\n          shader.vertexShader = shader.vertexShader.replace(token, token + insert);\n\n          token = '#include <begin_vertex>';\n\n          insert = /* glsl */`\n\t\t\t\t\t\tvec4 tmpPos = texture2D( texturePosition, reference.xy );\n\n\t\t\t\t\t\tvec3 pos = tmpPos.xyz;\n\t\t\t\t\t\tvec3 velocity = normalize(texture2D( textureVelocity, reference.xy ).xyz);\n\t\t\t\t\t\tvec3 aniPos = texture2D( textureAnimation, vec2( reference.z, mod( time + ( seeds.x ) * ( ( 0.0004 + seeds.y / 10000.0) + normalize( velocity ) / 20000.0 ), reference.w ) ) ).xyz;\n\t\t\t\t\t\tvec3 newPosition = position;\n\n\t\t\t\t\t\tnewPosition = mat3( modelMatrix ) * ( newPosition + aniPos );\n\t\t\t\t\t\tnewPosition *= size + seeds.y * size * 0.2;\n\n\t\t\t\t\t\tvelocity.z *= -1.;\n\t\t\t\t\t\tfloat xz = length( velocity.xz );\n\t\t\t\t\t\tfloat xyz = 1.;\n\t\t\t\t\t\tfloat x = sqrt( 1. - velocity.y * velocity.y );\n\n\t\t\t\t\t\tfloat cosry = velocity.x / xz;\n\t\t\t\t\t\tfloat sinry = velocity.z / xz;\n\n\t\t\t\t\t\tfloat cosrz = x / xyz;\n\t\t\t\t\t\tfloat sinrz = velocity.y / xyz;\n\n\t\t\t\t\t\tmat3 maty =  mat3( cosry, 0, -sinry, 0    , 1, 0     , sinry, 0, cosry );\n\t\t\t\t\t\tmat3 matz =  mat3( cosrz , sinrz, 0, -sinrz, cosrz, 0, 0     , 0    , 1 );\n\n\t\t\t\t\t\tnewPosition =  maty * matz * newPosition;\n\t\t\t\t\t\tnewPosition += pos;\n\n\t\t\t\t\t\tvec3 transformed = vec3( newPosition );\n\t\t\t\t\t`;\n\n          shader.vertexShader = shader.vertexShader.replace(token, insert);\n          materialShader = shader;\n        };\n\n        birdMesh = new THREE.Mesh(geometry, m);\n        birdMesh.rotation.y = Math.PI / 2;\n        birdMesh.position.x = 1300;\n        birdMesh.position.z = -2400;\n        birdMesh.position.y = 300;\n\n        birdMesh.castShadow = true;\n        birdMesh.receiveShadow = true;\n        scene.add(birdMesh);\n      }\n\n      function fillPositionTexture(texture) {\n        const theArray = texture.image.data;\n        for (let k = 0, kl = theArray.length; k < kl; k += 4) {\n          const x = Math.random() * BOUNDS - BOUNDS_HALF;\n          const y = Math.random() * BOUNDS - BOUNDS_HALF;\n          const z = Math.random() * BOUNDS - BOUNDS_HALF;\n\n          theArray[k + 0] = x;\n          theArray[k + 1] = y;\n          theArray[k + 2] = z;\n          theArray[k + 3] = 1;\n        }\n      }\n\n      function fillVelocityTexture(texture) {\n        const theArray = texture.image.data;\n        for (let k = 0, kl = theArray.length; k < kl; k += 4) {\n          const x = Math.random() - 0.5;\n          const y = Math.random() - 0.5;\n          const z = Math.random() - 0.5;\n          theArray[k + 0] = x * 10;\n          theArray[k + 1] = y * 10;\n          theArray[k + 2] = z * 10;\n          theArray[k + 3] = 1;\n        }\n      }\n\n\n      function onPointerMove(event) {\n        if (event.isPrimary === false) return;\n        mouseX = event.clientX - windowHalfX;\n        mouseY = event.clientY - windowHalfY;\n      }\n\n      function createText() {\n        textGeo = new THREE.TextGeometry(text, {\n          font: font,\n          size: size,\n          height: height,\n          curveSegments: curveSegments,\n          bevelThickness: bevelThickness,\n          bevelSize: bevelSize,\n          bevelEnabled: true\n        });\n\n        textGeo.computeBoundingBox();\n        textGeo.computeVertexNormals();\n\n        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);\n\n        if (mirror) {\n          textMesh2 = new THREE.Mesh(textGeo, material);\n          textMesh2.position.x = centerOffset;\n          textMesh2.position.y = -hover;\n          textMesh2.position.z = height;\n          textMesh2.rotation.x = Math.PI;\n          textMesh2.rotation.y = Math.PI * 2;\n          group.add(textMesh2);\n        }\n      }\n\n      function onWindowResize() {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n      }\n\n      function animate() {\n        requestAnimationFrame(animate);\n        group.position.x = -227;\n        group.position.y = 18;\n        group.position.z = -600;\n        group.rotation.y = 6.0;\n        group.rotation.x = 600.02;\n        group.rotation.z = 219.9;\n        render();\n      }\n\n\n      let radius = 2700;\n      let theta = 8;\n\n\n      function render() {\n        const now = performance.now();\n        const time = now * 0.0005;\n        for (let mesh of meshes) {\n          move(time, mesh);\n        }\n        water.material.uniforms['time'].value += 1.0 / 60.0;\n\n        if (theta < 33.7) {\n          theta += 0.1;\n          radius -= 10;\n\n          camera.position.x = radius * Math.sin(THREE.MathUtils.degToRad(theta)) - 45;\n          camera.position.y = radius / 3 * Math.sin(THREE.MathUtils.degToRad(theta));\n          camera.position.z = radius * Math.cos(THREE.MathUtils.degToRad(theta));\n        }\n\n\n        //camera.lookAt(scene.position);\n\n        let delta = (now - last) / 1000;\n        if (delta > 1) delta = 1; // safety cap on large deltas\n        last = now;\n        positionUniforms[\"time\"].value = now;\n        positionUniforms[\"delta\"].value = delta;\n        velocityUniforms[\"time\"].value = now;\n        velocityUniforms[\"delta\"].value = delta;\n        if (materialShader) materialShader.uniforms[\"time\"].value = now / 1000;\n        if (materialShader) materialShader.uniforms[\"delta\"].value = delta;\n\n        velocityUniforms[\"predator\"].value.set(0.5 * mouseX / windowHalfX, -0.5 * mouseY / windowHalfY, 0);\n\n        mouseX = 10000;\n        mouseY = 10000;\n\n        gpuCompute.compute();\n        if (materialShader) materialShader.uniforms[\"texturePosition\"].value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;\n        if (materialShader) materialShader.uniforms[\"textureVelocity\"].value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;\n\n\n        renderer.render(scene, camera);\n      }\n\n      function move(time, mesh) {\n        mesh.obj.position.y = Math.sin(time + mesh.pos.x) * 5 + mesh.pos.y;\n        mesh.obj.position.x = mesh.pos.x;\n        mesh.obj.position.z = mesh.pos.z;\n        mesh.obj.rotation.x = mesh.rot.x * time;\n        mesh.obj.rotation.z = mesh.rot.z * time;\n      }\n    }\n  }\n</script>\n\n<style scoped>\n  .app-container{\n    margin: 0;\n    padding: 0 !important;\n  }\n\n</style>\n"]}]}