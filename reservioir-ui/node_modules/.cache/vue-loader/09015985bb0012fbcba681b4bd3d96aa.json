{"remainingRequest":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\src\\views\\subsystem.vue?vue&type=style&index=0&id=289b6f76&scoped=true&lang=css&","dependencies":[{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\src\\views\\subsystem.vue","mtime":1640612301271},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\css-loader\\dist\\cjs.js","mtime":1711181251489},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":1711181253421},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\postcss-loader\\src\\index.js","mtime":1711181252308},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1711181250741},{"path":"D:\\GraduationProject\\final\\reservioir\\reservioir-ui\\node_modules\\vue-loader\\lib\\index.js","mtime":1711181252689}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLmFwcC1jb250YWluZXJ7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDAgIWltcG9ydGFudDsKfQoK"},{"version":3,"sources":["subsystem.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgzBA;AACA;AACA;AACA","file":"subsystem.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class='app-container'>\n    <div id=\"container\">\n\n    </div>\n  </div>\n</template>\n\n<script>\n  import * as THREE from 'three';\n  import {OrbitControls} from 'three/examples/jsm/controls/OrbitControls.js';\n  import {Water} from 'three/examples/jsm/objects/Water.js';\n  import {Sky} from 'three/examples/jsm/objects/Sky.js';\n  import {TTFLoader} from 'three/examples/jsm/loaders/TTFLoader.js';\n  import {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';\n  import {GPUComputationRenderer} from 'three/examples/jsm/misc/GPUComputationRenderer.js';\n\n  export default {\n    name: \"first\",\n    methods: {},\n    mounted() {\n      /* TEXTURE WIDTH FOR SIMULATION */\n      const WIDTH = 2;\n      const BIRDS = 4;\n\n      /* BAKE ANIMATION INTO TEXTURE and CREATE GEOMETRY FROM BASE MODEL */\n      const BirdGeometry = new THREE.BufferGeometry();\n      let textureAnimation, durationAnimation, birdMesh, materialShader, vertexPerBird;\n\n      function nextPowerOf2(n) {\n        return Math.pow(2, Math.ceil(Math.log(n) / Math.log(2)));\n      }\n\n      Math.lerp = function (value1, value2, amount) {\n        amount = Math.max(Math.min(amount, 1), 0);\n        return value1 + (value2 - value1) * amount;\n      };\n\n      const gltfs = ['files/glbs/Parrot.glb', 'files/glbs/Flamingo.glb'];\n      const selectModel = Math.floor(Math.random() * gltfs.length);\n      new GLTFLoader().load(gltfs[selectModel], function (gltf) {\n        const animations = gltf.animations;\n        durationAnimation = Math.round(animations[0].duration * 60);\n        const birdGeo = gltf.scene.children[0].geometry;\n        const morphAttributes = birdGeo.morphAttributes.position;\n        const tHeight = nextPowerOf2(durationAnimation);\n        const tWidth = nextPowerOf2(birdGeo.getAttribute('position').count);\n        vertexPerBird = birdGeo.getAttribute('position').count;\n        const tData = new Float32Array(3 * tWidth * tHeight);\n\n        for (let i = 0; i < tWidth; i++) {\n          for (let j = 0; j < tHeight; j++) {\n            const offset = j * tWidth * 3;\n            const curMorph = Math.floor(j / durationAnimation * morphAttributes.length);\n            const nextMorph = (Math.floor(j / durationAnimation * morphAttributes.length) + 1) % morphAttributes.length;\n            const lerpAmount = j / durationAnimation * morphAttributes.length % 1;\n\n            if (j < durationAnimation) {\n              let d0, d1;\n              d0 = morphAttributes[curMorph].array[i * 3];\n              d1 = morphAttributes[nextMorph].array[i * 3];\n              if (d0 !== undefined && d1 !== undefined) tData[offset + i * 3] = Math.lerp(d0, d1, lerpAmount);\n              d0 = morphAttributes[curMorph].array[i * 3 + 1];\n              d1 = morphAttributes[nextMorph].array[i * 3 + 1];\n              if (d0 !== undefined && d1 !== undefined) tData[offset + i * 3 + 1] = Math.lerp(d0, d1, lerpAmount);\n              d0 = morphAttributes[curMorph].array[i * 3 + 2];\n              d1 = morphAttributes[nextMorph].array[i * 3 + 2];\n              if (d0 !== undefined && d1 !== undefined) tData[offset + i * 3 + 2] = Math.lerp(d0, d1, lerpAmount);\n            }\n          }\n        }\n\n        textureAnimation = new THREE.DataTexture(tData, tWidth, tHeight, THREE.RGBFormat, THREE.FloatType);\n        textureAnimation.needsUpdate = true;\n\n        const vertices = [], color = [], reference = [], seeds = [], indices = [];\n        const totalVertices = birdGeo.getAttribute('position').count * 3 * BIRDS;\n        for (let i = 0; i < totalVertices; i++) {\n          const bIndex = i % (birdGeo.getAttribute('position').count * 3);\n          vertices.push(birdGeo.getAttribute('position').array[bIndex]);\n          color.push(birdGeo.getAttribute('color').array[bIndex]);\n        }\n\n        let r = Math.random();\n        for (let i = 0; i < birdGeo.getAttribute('position').count * BIRDS; i++) {\n          const bIndex = i % (birdGeo.getAttribute('position').count);\n          const bird = Math.floor(i / birdGeo.getAttribute('position').count);\n          if (bIndex === 0) r = Math.random();\n          const j = ~~bird;\n          const x = (j % WIDTH) / WIDTH;\n          const y = ~~(j / WIDTH) / WIDTH;\n          reference.push(x, y, bIndex / tWidth, durationAnimation / tHeight);\n          seeds.push(bird, r, Math.random(), Math.random());\n        }\n\n        for (let i = 0; i < birdGeo.index.array.length * BIRDS; i++) {\n          const offset = Math.floor(i / birdGeo.index.array.length) * (birdGeo.getAttribute('position').count);\n          indices.push(birdGeo.index.array[i % birdGeo.index.array.length] + offset);\n        }\n\n        BirdGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n        BirdGeometry.setAttribute('birdColor', new THREE.BufferAttribute(new Float32Array(color), 3));\n        BirdGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(color), 3));\n        BirdGeometry.setAttribute('reference', new THREE.BufferAttribute(new Float32Array(reference), 4));\n        BirdGeometry.setAttribute('seeds', new THREE.BufferAttribute(new Float32Array(seeds), 4));\n\n        BirdGeometry.setIndex(indices);\n\n        init();\n        animate();\n\n      });\n\n\n      let container, stats;\n      let camera, scene, renderer;\n      let mouseX = 0, mouseY = 0;\n\n      let windowHalfX = window.innerWidth / 2;\n      let windowHalfY = window.innerHeight / 2;\n\n      const BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;\n\n      let last = performance.now();\n\n      let gpuCompute;\n      let velocityVariable;\n      let positionVariable;\n      let positionUniforms;\n      let velocityUniforms;\n\n      let controls, water, sun;\n      let meshes;\n      let iniMeshes = function () {\n        meshes = [\n          {\n            name: 'mesh0',\n            pos: {x: -60, y: 0, z: 60},\n            url: '#',\n            img: require('@/assets/flash/monitor.png'),\n            rot: {x: 0.1, y: 0.2, z: 0.5}\n          },\n\n          {\n            name: 'mesh2',\n            pos: {x: -0, y: 0, z: 40},\n            url: '/reservoir',\n            img: require('@/assets/flash/manage.png'),\n            rot: {x: 0.3, y: 0.2, z: 0.3}\n          },\n\n          {\n            name: 'mesh4',\n            pos: {x: 60, y: 0, z: 40},\n            url: '#',\n            img: require('@/assets/flash/apprise.png'),\n            rot: {x: 0.5, y: 0.2, z: 0.1}\n          },\n        ];\n      }();\n\n\n      let group, textMesh1, textMesh2, textGeo, material;\n\n      let text = '滕州市数字水库监管平台';\n      const height = 20,\n        size = 70,\n        hover = 30,\n        curveSegments = 4,\n        bevelThickness = 2,\n        bevelSize = 1.5;\n\n      let font = null;\n      const mirror = true;\n\n\n      let inArea = false;\n      let currentIndex = null;\n\n\n      addTouch();\n\n      function addTouch() {\n        function onMouseMove(event) {\n          let intersect = getIntersect();\n          if (intersect) {\n            document.body.style.cursor = \"pointer\";\n            let mesh = meshes[intersect.object.index];\n            currentIndex = intersect.object.index;\n            mesh.rot.x = 0;\n            mesh.rot.z = 0;\n            mesh.rot.y = 0;\n            mesh.pos.y = 5;\n            inArea = true;\n            render();\n          } else {\n            if (inArea) {\n              inArea = false;\n              meshes[currentIndex].rot.x = (currentIndex + 1) * 0.1;\n              meshes[currentIndex].rot.y = 0.2;\n              meshes[currentIndex].rot.z = (meshes.length - currentIndex - 1) * 0.1;\n              meshes[currentIndex].pos.y = 0;\n              render();\n            }\n            document.body.style.cursor = \"default\";\n          }\n        }\n\n        function onMouseClick(event) {\n          let intersect = getIntersect();\n          if (intersect) {\n            window.location.href = findMesh(intersect.object.position.x).url;\n          }\n        }\n\n        function findMesh(x) {\n          for (let mesh of meshes) {\n            if (x === mesh.pos.x) {\n              return mesh;\n            }\n          }\n        }\n\n        function getIntersect() {\n          //声明射线和mouse变量\n          let raycaster = new THREE.Raycaster();\n          let mouse = new THREE.Vector2();\n\n          //通过鼠标点击的位置计算出射线所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.\n          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n          //根据在屏幕的二维位置以及相机的矩阵更新射线的位置\n          raycaster.setFromCamera(mouse, camera);\n\n          // 获取射线直线和所有模型相交的数组集合\n          let intersects = raycaster.intersectObjects(scene.children, true); //增加第二个参数，可以遍历子子孙孙对象\n          //判断当前数组是否为空,不为空则获取最近的的模型，将其颜色修改为红色\n          if (intersects.length > 2) {\n            for (let intersect of intersects) {\n              if (intersect.object instanceof THREE.Mesh && (intersect.object.index >= 0)) {\n                return intersect;\n              }\n            }\n          }\n        }\n\n        document.addEventListener(\"click\", onMouseClick, false);\n        document.addEventListener(\"mousemove\", onMouseMove, false);\n      }\n\n      function init() {\n        container = document.getElementById('container');\n\n        renderer = new THREE.WebGLRenderer();\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.toneMapping = THREE.ACESFilmicToneMapping;\n        container.appendChild(renderer.domElement);\n        //\n\n        scene = new THREE.Scene();\n\n        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 20000);\n        camera.position.set(30, 30, 100);\n        //\n\n        sun = new THREE.Vector3();\n\n        // Water\n        const waterGeometry = new THREE.PlaneGeometry(10000, 10000);\n        water = new Water(\n          waterGeometry,\n          {\n            textureWidth: 512,\n            textureHeight: 512,\n            waterNormals: new THREE.TextureLoader().load(require('@/assets/flash/waternormals.jpg'), function (texture) {\n              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n            }),\n            sunDirection: new THREE.Vector3(),\n            sunColor: 0xffffff,\n            waterColor: 0x001e0f,\n            distortionScale: 10,\n            fog: scene.fog !== undefined\n          }\n        );\n        water.rotation.x = -Math.PI / 2;\n        scene.add(water);\n\n        // Skybox\n        const sky = new Sky();\n        sky.scale.setScalar(10000);\n        scene.add(sky);\n\n        const skyUniforms = sky.material.uniforms;\n        skyUniforms['turbidity'].value = 10;\n        skyUniforms['rayleigh'].value = 9;\n        skyUniforms['mieCoefficient'].value = 0.005;\n        skyUniforms['mieDirectionalG'].value = 0.8;\n\n        const parameters = {\n          elevation: ((12 - Math.abs(new Date().getHours() + new Date().getMinutes() / 60 - 12)) * 40 / 12 - 20) * 2,\n          azimuth: (12 - new Date().getHours() - new Date().getMinutes() / 60) * 10 - 170\n        };\n\n        const pmremGenerator = new THREE.PMREMGenerator(renderer);\n\n        let updateSun = function () {\n          const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);\n          const theta = THREE.MathUtils.degToRad(parameters.azimuth);\n\n          sun.setFromSphericalCoords(1, phi, theta);\n          sky.material.uniforms['sunPosition'].value.copy(sun);\n          water.material.uniforms['sunDirection'].value.copy(sun).normalize();\n          scene.environment = pmremGenerator.fromScene(sky).texture;\n        }();\n\n        const geometry = new THREE.BoxGeometry(20, 20, 20);\n\n        for (let i = 0; i < meshes.length; i++) {\n          const texture = new THREE.TextureLoader().load(meshes[i].img);\n          const material = new THREE.MeshStandardMaterial({map: texture});\n\n          let m = new THREE.Mesh(geometry, material);\n          m.index = i;\n          scene.add(m);\n          meshes[i].obj = m;\n        }\n\n        const geo = new THREE.BoxGeometry(30, 30, 30);\n        const tex = new THREE.TextureLoader().load(require('@/assets/logo/water.png'));\n        const mat = new THREE.MeshStandardMaterial({map: tex});\n        let iconMesh = new THREE.Mesh(geo, mat);\n        iconMesh.position.x = -800;\n        iconMesh.position.y = 88;\n        iconMesh.position.z = -500;\n        iconMesh.rotation.y = 7.24;\n        iconMesh.rotation.x = 9.5;\n        iconMesh.rotation.z = 9.4;\n        scene.add(iconMesh);   //版权问题，暂时不开启\n\n        controls = new OrbitControls(camera, renderer.domElement);\n        controls.maxPolarAngle = Math.PI * 0.495;\n        controls.target.set(0, 10, 0);\n        controls.minDistance = 50.0;\n        controls.maxDistance = 4800.0;\n        controls.update();\n\n        //\n        const dirLight = new THREE.DirectionalLight(0xffffff, 0.125);\n        dirLight.position.set(0, 0, 1).normalize();\n        scene.add(dirLight);\n\n        const pointLight = new THREE.PointLight(0xffffff, 1.5);\n        pointLight.position.set(0, 200, 90);\n        pointLight.color.setHSL(0.1, 1, 0.3);\n        scene.add(pointLight);\n\n        material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading: true});\n        //\n        group = new THREE.Group();\n        group.position.y = 100;\n\n        scene.add(group);\n\n        const loader = new TTFLoader();\n\n        loader.load(require('@/assets/flash/title.ttf'), function (json) {\n          font = new THREE.Font(json);\n          createText();\n        });\n\n\n        camera.updateMatrixWorld();\n\n        initComputeRenderer();\n        initBirds();\n        container.style.touchAction = 'none';\n        container.addEventListener('pointermove', onPointerMove);\n\n        window.addEventListener('resize', onWindowResize);\n      }\n\n      function initComputeRenderer() {\n        gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n\n        const dtPosition = gpuCompute.createTexture();\n        const dtVelocity = gpuCompute.createTexture();\n        fillPositionTexture(dtPosition);\n        fillVelocityTexture(dtVelocity);\n\n        velocityVariable = gpuCompute.addVariable(\"textureVelocity\",\n          'uniform float time;\\n' +\n          '\\t\\t\\tuniform float testing;\\n' +\n          '\\t\\t\\tuniform float delta; // about 0.016\\n' +\n          '\\t\\t\\tuniform float separationDistance; // 20\\n' +\n          '\\t\\t\\tuniform float alignmentDistance; // 40\\n' +\n          '\\t\\t\\tuniform float cohesionDistance; //\\n' +\n          '\\t\\t\\tuniform float freedomFactor;\\n' +\n          '\\t\\t\\tuniform vec3 predator;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float width = resolution.x;\\n' +\n          '\\t\\t\\tconst float height = resolution.y;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float PI = 3.141592653589793;\\n' +\n          '\\t\\t\\tconst float PI_2 = PI * 2.0;\\n' +\n          '\\t\\t\\t// const float VISION = PI * 0.55;\\n' +\n          '\\n' +\n          '\\t\\t\\tfloat zoneRadius = 40.0;\\n' +\n          '\\t\\t\\tfloat zoneRadiusSquared = 1600.0;\\n' +\n          '\\n' +\n          '\\t\\t\\tfloat separationThresh = 0.45;\\n' +\n          '\\t\\t\\tfloat alignmentThresh = 0.65;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float UPPER_BOUNDS = BOUNDS;\\n' +\n          '\\t\\t\\tconst float LOWER_BOUNDS = -UPPER_BOUNDS;\\n' +\n          '\\n' +\n          '\\t\\t\\tconst float SPEED_LIMIT = 9.0;\\n' +\n          '\\n' +\n          '\\t\\t\\tfloat rand( vec2 co ){\\n' +\n          '\\t\\t\\t\\treturn fract( sin( dot( co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );\\n' +\n          '\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\t\\t\\tvoid main() {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tzoneRadius = separationDistance + alignmentDistance + cohesionDistance;\\n' +\n          '\\t\\t\\t\\tseparationThresh = separationDistance / zoneRadius;\\n' +\n          '\\t\\t\\t\\talignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;\\n' +\n          '\\t\\t\\t\\tzoneRadiusSquared = zoneRadius * zoneRadius;\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n          '\\t\\t\\t\\tvec3 birdPosition, birdVelocity;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec3 selfPosition = texture2D( texturePosition, uv ).xyz;\\n' +\n          '\\t\\t\\t\\tvec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat dist;\\n' +\n          '\\t\\t\\t\\tvec3 dir; // direction\\n' +\n          '\\t\\t\\t\\tfloat distSquared;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat separationSquared = separationDistance * separationDistance;\\n' +\n          '\\t\\t\\t\\tfloat cohesionSquared = cohesionDistance * cohesionDistance;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat f;\\n' +\n          '\\t\\t\\t\\tfloat percent;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec3 velocity = selfVelocity;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat limit = SPEED_LIMIT;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tdir = predator * UPPER_BOUNDS - selfPosition;\\n' +\n          '\\t\\t\\t\\tdir.z = 0.;\\n' +\n          '\\t\\t\\t\\t// dir.z *= 0.6;\\n' +\n          '\\t\\t\\t\\tdist = length( dir );\\n' +\n          '\\t\\t\\t\\tdistSquared = dist * dist;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat preyRadius = 150.0;\\n' +\n          '\\t\\t\\t\\tfloat preyRadiusSq = preyRadius * preyRadius;\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// move birds away from predator\\n' +\n          '\\t\\t\\t\\tif ( dist < preyRadius ) {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\tf = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;\\n' +\n          '\\t\\t\\t\\t\\tvelocity += normalize( dir ) * f;\\n' +\n          '\\t\\t\\t\\t\\tlimit += 5.0;\\n' +\n          '\\t\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// if (testing == 0.0) {}\\n' +\n          '\\t\\t\\t\\t// if ( rand( uv + time ) < freedomFactor ) {}\\n' +\n          '\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// Attract flocks to the center\\n' +\n          '\\t\\t\\t\\tvec3 central = vec3( 0., 0., 0. );\\n' +\n          '\\t\\t\\t\\tdir = selfPosition - central;\\n' +\n          '\\t\\t\\t\\tdist = length( dir );\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tdir.y *= 2.5;\\n' +\n          '\\t\\t\\t\\tvelocity -= normalize( dir ) * delta * 5.;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfor ( float y = 0.0; y < height; y++ ) {\\n' +\n          '\\t\\t\\t\\t\\tfor ( float x = 0.0; x < width; x++ ) {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tvec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;\\n' +\n          '\\t\\t\\t\\t\\t\\tbirdPosition = texture2D( texturePosition, ref ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tdir = birdPosition - selfPosition;\\n' +\n          '\\t\\t\\t\\t\\t\\tdist = length( dir );\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tif ( dist < 0.0001 ) continue;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tdistSquared = dist * dist;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tif ( distSquared > zoneRadiusSquared ) continue;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tpercent = distSquared / zoneRadiusSquared;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\tif ( percent < separationThresh ) { // low\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\t// Separation - Move apart for comfort\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tf = ( separationThresh / percent - 1.0 ) * delta;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tvelocity -= normalize( dir ) * f;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t} else if ( percent < alignmentThresh ) { // high\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\t// Alignment - fly the same direction\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat threshDelta = alignmentThresh - separationThresh;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat adjustedPercent = ( percent - separationThresh ) / threshDelta;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tbirdVelocity = texture2D( textureVelocity, ref ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tf = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tvelocity += normalize( birdVelocity ) * f;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t} else {\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\t// Attraction / Cohesion - move closer\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat threshDelta = 1.0 - alignmentThresh;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tfloat adjustedPercent;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tif( threshDelta == 0. ) adjustedPercent = 1.;\\n' +\n          '\\t\\t\\t\\t\\t\\t\\telse adjustedPercent = ( percent - alignmentThresh ) / threshDelta;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tf = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t\\t\\t\\tvelocity += normalize( dir ) * f;\\n' +\n          '\\t\\t\\t\\t\\t\\t}\\n' +\n          '\\t\\t\\t\\t\\t}\\n' +\n          '\\t\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// this make tends to fly around than down or up\\n' +\n          '\\t\\t\\t\\t// if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);\\n' +\n          '\\n' +\n          '\\t\\t\\t\\t// Speed Limits\\n' +\n          '\\t\\t\\t\\tif ( length( velocity ) > limit ) {\\n' +\n          '\\t\\t\\t\\t\\tvelocity = normalize( velocity ) * limit;\\n' +\n          '\\t\\t\\t\\t}\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tgl_FragColor = vec4( velocity, 1.0 );\\n' +\n          '\\n' +\n          '\\t\\t\\t}\\n', dtVelocity);\n        positionVariable = gpuCompute.addVariable(\"texturePosition\",\n          'uniform float time;\\n' +\n          '\\t\\t\\tuniform float delta;\\n' +\n          '\\n' +\n          '\\t\\t\\tvoid main()\\t{\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n          '\\t\\t\\t\\tvec4 tmpPos = texture2D( texturePosition, uv );\\n' +\n          '\\t\\t\\t\\tvec3 position = tmpPos.xyz;\\n' +\n          '\\t\\t\\t\\tvec3 velocity = texture2D( textureVelocity, uv ).xyz;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tfloat phase = tmpPos.w;\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tphase = mod( ( phase + delta +\\n' +\n          '\\t\\t\\t\\t\\tlength( velocity.xz ) * delta * 3. +\\n' +\n          '\\t\\t\\t\\t\\tmax( velocity.y, 0.0 ) * delta * 6. ), 62.83 );\\n' +\n          '\\n' +\n          '\\t\\t\\t\\tgl_FragColor = vec4( position + velocity * delta * 15. , phase );\\n' +\n          '\\n' +\n          '\\t\\t\\t}'\n\n          , dtPosition);\n\n        gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n        gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n\n        positionUniforms = positionVariable.material.uniforms;\n        velocityUniforms = velocityVariable.material.uniforms;\n\n        positionUniforms[\"time\"] = {value: 0.0};\n        positionUniforms[\"delta\"] = {value: 0.0};\n        velocityUniforms[\"time\"] = {value: 1.0};\n        velocityUniforms[\"delta\"] = {value: 0.0};\n        velocityUniforms[\"testing\"] = {value: 1.0};\n        velocityUniforms[\"separationDistance\"] = {value: 1.0};\n        velocityUniforms[\"alignmentDistance\"] = {value: 1.0};\n        velocityUniforms[\"cohesionDistance\"] = {value: 1.0};\n        velocityUniforms[\"freedomFactor\"] = {value: 1.0};\n        velocityUniforms[\"predator\"] = {value: new THREE.Vector3()};\n        velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2);\n\n        velocityVariable.wrapS = THREE.RepeatWrapping;\n        velocityVariable.wrapT = THREE.RepeatWrapping;\n        positionVariable.wrapS = THREE.RepeatWrapping;\n        positionVariable.wrapT = THREE.RepeatWrapping;\n\n        const error = gpuCompute.init();\n\n        if (error !== null) {\n\n          console.error(error);\n\n        }\n\n      }\n\n      function initBirds() {\n        const geometry = BirdGeometry;\n        const m = new THREE.MeshStandardMaterial({\n          vertexColors: true,\n          flatShading: true,\n          roughness: 1,\n          metalness: 0\n        });\n\n        m.onBeforeCompile = (shader) => {\n          shader.uniforms.texturePosition = {value: null};\n          shader.uniforms.textureVelocity = {value: null};\n          shader.uniforms.textureAnimation = {value: textureAnimation};\n          shader.uniforms.time = {value: 1.0};\n          shader.uniforms.size = {value: 0.3};\n          shader.uniforms.delta = {value: 0.0};\n\n          let token = '#define STANDARD';\n\n          let insert = /* glsl */`\n\t\t\t\t\t\tattribute vec4 reference;\n\t\t\t\t\t\tattribute vec4 seeds;\n\t\t\t\t\t\tattribute vec3 birdColor;\n\t\t\t\t\t\tuniform sampler2D texturePosition;\n\t\t\t\t\t\tuniform sampler2D textureVelocity;\n\t\t\t\t\t\tuniform sampler2D textureAnimation;\n\t\t\t\t\t\tuniform float size;\n\t\t\t\t\t\tuniform float time;\n\t\t\t\t\t`;\n\n          shader.vertexShader = shader.vertexShader.replace(token, token + insert);\n\n          token = '#include <begin_vertex>';\n\n          insert = /* glsl */`\n\t\t\t\t\t\tvec4 tmpPos = texture2D( texturePosition, reference.xy );\n\n\t\t\t\t\t\tvec3 pos = tmpPos.xyz;\n\t\t\t\t\t\tvec3 velocity = normalize(texture2D( textureVelocity, reference.xy ).xyz);\n\t\t\t\t\t\tvec3 aniPos = texture2D( textureAnimation, vec2( reference.z, mod( time + ( seeds.x ) * ( ( 0.0004 + seeds.y / 10000.0) + normalize( velocity ) / 20000.0 ), reference.w ) ) ).xyz;\n\t\t\t\t\t\tvec3 newPosition = position;\n\n\t\t\t\t\t\tnewPosition = mat3( modelMatrix ) * ( newPosition + aniPos );\n\t\t\t\t\t\tnewPosition *= size + seeds.y * size * 0.2;\n\n\t\t\t\t\t\tvelocity.z *= -1.;\n\t\t\t\t\t\tfloat xz = length( velocity.xz );\n\t\t\t\t\t\tfloat xyz = 1.;\n\t\t\t\t\t\tfloat x = sqrt( 1. - velocity.y * velocity.y );\n\n\t\t\t\t\t\tfloat cosry = velocity.x / xz;\n\t\t\t\t\t\tfloat sinry = velocity.z / xz;\n\n\t\t\t\t\t\tfloat cosrz = x / xyz;\n\t\t\t\t\t\tfloat sinrz = velocity.y / xyz;\n\n\t\t\t\t\t\tmat3 maty =  mat3( cosry, 0, -sinry, 0    , 1, 0     , sinry, 0, cosry );\n\t\t\t\t\t\tmat3 matz =  mat3( cosrz , sinrz, 0, -sinrz, cosrz, 0, 0     , 0    , 1 );\n\n\t\t\t\t\t\tnewPosition =  maty * matz * newPosition;\n\t\t\t\t\t\tnewPosition += pos;\n\n\t\t\t\t\t\tvec3 transformed = vec3( newPosition );\n\t\t\t\t\t`;\n\n          shader.vertexShader = shader.vertexShader.replace(token, insert);\n          materialShader = shader;\n        };\n\n        birdMesh = new THREE.Mesh(geometry, m);\n        birdMesh.rotation.y = Math.PI / 2;\n        birdMesh.position.x = 1300;\n        birdMesh.position.z = -2400;\n        birdMesh.position.y = 300;\n\n        birdMesh.castShadow = true;\n        birdMesh.receiveShadow = true;\n        scene.add(birdMesh);\n      }\n\n      function fillPositionTexture(texture) {\n        const theArray = texture.image.data;\n        for (let k = 0, kl = theArray.length; k < kl; k += 4) {\n          const x = Math.random() * BOUNDS - BOUNDS_HALF;\n          const y = Math.random() * BOUNDS - BOUNDS_HALF;\n          const z = Math.random() * BOUNDS - BOUNDS_HALF;\n\n          theArray[k + 0] = x;\n          theArray[k + 1] = y;\n          theArray[k + 2] = z;\n          theArray[k + 3] = 1;\n        }\n      }\n\n      function fillVelocityTexture(texture) {\n        const theArray = texture.image.data;\n        for (let k = 0, kl = theArray.length; k < kl; k += 4) {\n          const x = Math.random() - 0.5;\n          const y = Math.random() - 0.5;\n          const z = Math.random() - 0.5;\n          theArray[k + 0] = x * 10;\n          theArray[k + 1] = y * 10;\n          theArray[k + 2] = z * 10;\n          theArray[k + 3] = 1;\n        }\n      }\n\n\n      function onPointerMove(event) {\n        if (event.isPrimary === false) return;\n        mouseX = event.clientX - windowHalfX;\n        mouseY = event.clientY - windowHalfY;\n      }\n\n      function createText() {\n        textGeo = new THREE.TextGeometry(text, {\n          font: font,\n          size: size,\n          height: height,\n          curveSegments: curveSegments,\n          bevelThickness: bevelThickness,\n          bevelSize: bevelSize,\n          bevelEnabled: true\n        });\n\n        textGeo.computeBoundingBox();\n        textGeo.computeVertexNormals();\n\n        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);\n\n        if (mirror) {\n          textMesh2 = new THREE.Mesh(textGeo, material);\n          textMesh2.position.x = centerOffset;\n          textMesh2.position.y = -hover;\n          textMesh2.position.z = height;\n          textMesh2.rotation.x = Math.PI;\n          textMesh2.rotation.y = Math.PI * 2;\n          group.add(textMesh2);\n        }\n      }\n\n      function onWindowResize() {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n      }\n\n      function animate() {\n        requestAnimationFrame(animate);\n        group.position.x = -227;\n        group.position.y = 18;\n        group.position.z = -600;\n        group.rotation.y = 6.0;\n        group.rotation.x = 600.02;\n        group.rotation.z = 219.9;\n        render();\n      }\n\n\n      let radius = 2700;\n      let theta = 8;\n\n\n      function render() {\n        const now = performance.now();\n        const time = now * 0.0005;\n        for (let mesh of meshes) {\n          move(time, mesh);\n        }\n        water.material.uniforms['time'].value += 1.0 / 60.0;\n\n        if (theta < 33.7) {\n          theta += 0.1;\n          radius -= 10;\n\n          camera.position.x = radius * Math.sin(THREE.MathUtils.degToRad(theta)) - 45;\n          camera.position.y = radius / 3 * Math.sin(THREE.MathUtils.degToRad(theta));\n          camera.position.z = radius * Math.cos(THREE.MathUtils.degToRad(theta));\n        }\n\n\n        //camera.lookAt(scene.position);\n\n        let delta = (now - last) / 1000;\n        if (delta > 1) delta = 1; // safety cap on large deltas\n        last = now;\n        positionUniforms[\"time\"].value = now;\n        positionUniforms[\"delta\"].value = delta;\n        velocityUniforms[\"time\"].value = now;\n        velocityUniforms[\"delta\"].value = delta;\n        if (materialShader) materialShader.uniforms[\"time\"].value = now / 1000;\n        if (materialShader) materialShader.uniforms[\"delta\"].value = delta;\n\n        velocityUniforms[\"predator\"].value.set(0.5 * mouseX / windowHalfX, -0.5 * mouseY / windowHalfY, 0);\n\n        mouseX = 10000;\n        mouseY = 10000;\n\n        gpuCompute.compute();\n        if (materialShader) materialShader.uniforms[\"texturePosition\"].value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;\n        if (materialShader) materialShader.uniforms[\"textureVelocity\"].value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;\n\n\n        renderer.render(scene, camera);\n      }\n\n      function move(time, mesh) {\n        mesh.obj.position.y = Math.sin(time + mesh.pos.x) * 5 + mesh.pos.y;\n        mesh.obj.position.x = mesh.pos.x;\n        mesh.obj.position.z = mesh.pos.z;\n        mesh.obj.rotation.x = mesh.rot.x * time;\n        mesh.obj.rotation.z = mesh.rot.z * time;\n      }\n    }\n  }\n</script>\n\n<style scoped>\n  .app-container{\n    margin: 0;\n    padding: 0 !important;\n  }\n\n</style>\n"]}]}